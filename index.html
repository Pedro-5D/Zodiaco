<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>izarren.top</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/css/bootstrap.min.css">
    <style>
        body {
            font-family: 'Segoe UI', Arial, sans-serif;
            background-color: #f0f0f0;
            margin: 0;
            padding: 20px;
            color: #333;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        .chart-container {
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            padding: 20px;
            margin-bottom: 20px;
        }
        .controls-container {
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            padding: 20px;
            margin-bottom: 20px;
        }
        .info-container {
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            padding: 20px;
            margin-bottom: 20px;
            max-height: 600px;
            overflow-y: auto;
        }
        .coincidencias-container {
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            padding: 20px;
            margin-bottom: 20px;
            max-height: 600px;
            overflow-y: auto;
        }
        .wheel-container {
            position: relative;
            width: 100%;
            max-width: 800px;
            height: auto;
            aspect-ratio: 1/1;
            margin: 0 auto;
        }
        .chart-svg {
            width: 100%;
            height: 100%;
        }
        .planet-symbol {
            font-weight: bold;
            cursor: pointer;
        }
        .aspect-line {
            cursor: pointer;
        }
        .hidden {
            display: none;
        }
        .year-container {
            margin-bottom: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            overflow: hidden;
        }
        .year-header {
            background-color: #f8f9fa;
            padding: 10px 15px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .year-content {
            padding: 15px;
            display: none;
        }
        .expanded {
            display: block;
        }
        .coincidence-date {
            margin: 5px 0;
            padding: 8px;
            border-radius: 4px;
            background-color: #f1f1f1;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .coincidence-date:hover {
            background-color: #e9e9e9;
        }
        .planet-btn {
            margin-right: 5px;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: white;
            border: none;
            cursor: pointer;
        }
        .tooltip-custom {
            position: absolute;
            padding: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            border-radius: 5px;
            font-size: 14px;
            pointer-events: none;
            z-index: 1000;
        }
        .tab-content {
            padding: 15px;
        }
        .loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 9999;
        }
        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 5px solid #f3f3f3;
            border-top: 5px solid #3498db;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .btn-coincidence {
            margin: 2px;
            padding: 5px 10px;
            font-size: 0.8rem;
        }
        .planet-list-item {
            padding: 8px;
            margin: 5px 0;
            border-radius: 4px;
            cursor: pointer;
        }
        .planet-list-item:hover {
            background-color: #f0f0f0;
        }
        .planet-list-item.selected {
            background-color: #e3f2fd;
        }
        .aspect-list-item {
            padding: 8px;
            margin: 5px 0;
            border-radius: 4px;
            cursor: pointer;
        }
        .aspect-list-item:hover {
            background-color: #f0f0f0;
        }
        .aspect-list-item.selected {
            background-color: #e3f2fd;
        }
        .dignity-domicilio {
            color: #00AA00;
            font-weight: bold;
        }
        .dignity-exaltacion {
            color: #4444FF;
            font-weight: bold;
        }
        .dignity-peregrino {
            color: #888888;
        }
        .dignity-caida {
            color: #AA5500;
            font-weight: bold;
        }
        .dignity-exilio {
            color: #AA0000;
            font-weight: bold;
        }
        .enlace-item {
            padding: 8px;
            margin: 5px 0;
            border-radius: 4px;
            border-left: 4px solid #ddd;
        }
        .enlace-fuerte {
            border-left-color: #28a745;
            background-color: #f0fff0;
        }
        .enlace-medio {
            border-left-color: #ffc107;
            background-color: #fffff0;
        }
        .enlace-debil {
            border-left-color: #dc3545;
            background-color: #fff0f0;
        }
        .pico-item {
            padding: 10px;
            margin: 5px 0;
            border-radius: 4px;
            background-color: #f8f9fa;
            border-left: 4px solid #28a745;
        }
        .header-title {
            text-align: center;
            margin-bottom: 30px;
            color: #1a237e;
            font-size: 2.5rem;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
            padding: 10px 0;
            border-bottom: 2px solid #3949ab;
            background-color: #f5f5f5;
            border-radius: 10px;
        }
        /* Nuevos estilos para predicciones */
        .predicciones-container {
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            padding: 20px;
            margin-bottom: 20px;
            max-height: 600px;
            overflow-y: auto;
        }
        .prediccion-item {
            padding: 8px;
            margin: 5px 0;
            border-radius: 4px;
            cursor: pointer;
            border-left: 4px solid #007bff;
            background-color: #f8f9fa;
        }
        .prediccion-item:hover {
            background-color: #e9ecef;
        }
        .prediccion-fecha {
            font-weight: bold;
        }
        .prediccion-pico-mayor {
            border-left-color: #dc3545;
        }
        .prediccion-pico-moderado {
            border-left-color: #fd7e14;
        }
        .prediccion-pico-menor {
            border-left-color: #ffc107;
        }
        .prediccion-liberacion {
            border-left-color: #28a745;
        }
        .prediccion-disolucion {
            border-left-color: #6c757d;
        }
        .date-filter {
            margin-bottom: 15px;
        }
        .year-group {
            margin-bottom: 15px;
            border: 1px solid #dee2e6;
            border-radius: 5px;
        }
        .year-header {
            padding: 10px 15px;
            background-color: #f8f9fa;
            border-bottom: 1px solid #dee2e6;
            font-weight: bold;
            cursor: pointer;
        }
        /* Estilos para botones de puntos de referencia */
        .punto-referencia-btn {
            margin-right: 5px;
            margin-bottom: 10px;
        }
        .punto-referencia-btn.active {
            background-color: #0d6efd;
            color: white;
        }
        .punto-info {
            margin-top: 10px;
            padding: 10px;
            background-color: #f8f9fa;
            border-radius: 5px;
            border-left: 4px solid #0d6efd;
        }
        /* Estilos para Relevo Zodiacal */
        .relevo-periodo {
            padding: 10px;
            margin-bottom: 10px;
            border-radius: 4px;
            border-left: 4px solid #ccc;
        }
        .relevo-subperiodo {
            margin-left: 20px;
            margin-bottom: 5px;
        }
        .relevo-subsubperiodo {
            margin-left: 40px;
            margin-bottom: 5px;
        }
        .fuego {
            background-color: #fff5e6;
            border-left-color: #ff9933;
        }
        .tierra {
            background-color: #f0f7e6;
            border-left-color: #7fb352;
        }
        .aire {
            background-color: #e6f2ff;
            border-left-color: #33a3ff;
        }
        .agua {
            background-color: #e6e6ff;
            border-left-color: #8080ff;
        }
        .periodo-activo {
            border-left-width: 6px !important;
            background-color: rgba(255, 255, 255, 0.7) !important;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1) !important;
        }
		/* Styles for retrograde and stationary symbols */
        .retrograde {
            color: #dc3545;
            font-weight: bold;
        }
       .stationary-retrograde {
            color: #fd7e14;
            font-weight: bold;
        }
        .stationary-direct {
            color: #20c997;
            font-weight: bold;
        }
		/* Estilos para estrellas fijas */
.fixed-stars-container {
    margin-top: 20px;
    padding: 20px;
    background: white;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.stars-list {
    max-height: 400px;
    overflow-y: auto;
}

.star-item {
    padding: 10px;
    margin-bottom: 10px;
    border-radius: 6px;
    background-color: #f8f9fa;
    border-left: 3px solid #FFD700;
    cursor: pointer;
    transition: all 0.2s ease;
}

.star-item:hover {
    background-color: #f0f0f0;
}

.star-item.selected {
    background-color: #fff9e5;
    border-left-width: 5px;
}

.star-header {
    font-weight: bold;
    margin-bottom: 5px;
}

.star-symbol {
    color: #FFD700;
    text-shadow: 0 0 2px #000;
    margin-right: 5px;
}

.star-details {
    font-size: 0.9em;
    margin-left: 20px;
}

.star-interpretation {
    margin-top: 10px;
    padding-top: 10px;
    border-top: 1px dashed #e9e9e9;
}

.physical-plane, .astral-plane {
    margin-top: 5px;
}

.plane-title {
    font-weight: 600;
    color: #333;
}

/* Estilos para indicadores de estrellas en la rueda */
.star-point {
    fill: #FFD700;
    stroke: #000;
    stroke-width: 0.5;
    cursor: pointer;
}

.star-point:hover {
    fill: #FFC800;
    transform: scale(1.2);
}

.star-point.selected {
    fill: #FF9900;
    stroke-width: 1;
}

.star-label {
    font-size: 8px;
    font-weight: bold;
    pointer-events: none;
}
    </style>
</head>
<body>
    <div class="container">
        <h1 class="header-title">www.izarren.top</h1>
        
        <div class="loading" id="loadingIndicator">
            <div class="loading-spinner"></div>
        </div>
        
        <!-- Formulario de entrada -->
        <div class="controls-container mb-4">
            <div class="row">
                <div class="col-md-4">
                    <div class="mb-3">
                        <label for="city" class="form-label">Ciudad de Nacimiento</label>
                        <input type="text" class="form-control" id="city" placeholder="Ej: Madrid, España" list="cityList">
                        <datalist id="cityList"></datalist>
                    </div>
                </div>
                <div class="col-md-4">
                    <div class="mb-3">
                        <label for="date" class="form-label">Fecha de Nacimiento</label>
                        <input type="date" class="form-control" id="date">
                    </div>
                </div>
                <div class="col-md-4">
                    <div class="mb-3">
                        <label for="time" class="form-label">Hora de Nacimiento</label>
                        <input type="time" class="form-control" id="time">
                    </div>
                </div>
            </div>

            <!-- Formulario de tránsitos -->
            <div class="row mb-3">
                <div class="col-md-4">
                    <div class="form-check form-switch">
                        <input class="form-check-input" type="checkbox" id="showTransits" checked>
                        <label class="form-check-label" for="showTransits">Mostrar Tránsitos</label>
                    </div>
                </div>
                <div class="col-md-4">
                    <div class="form-check form-switch">
                        <input class="form-check-input" type="checkbox" id="calculateAnalysis" checked>
                        <label class="form-check-label" for="calculateAnalysis">Análisis Avanzado</label>
                    </div>
                </div>
                <div class="col-md-4">
                    <div class="form-check form-switch">
                        <input class="form-check-input" type="checkbox" id="calculatePredictions">
                        <label class="form-check-label" for="calculatePredictions">Calcular Predicciones (84 años)</label>
                    </div>
                </div>
            </div>
			
			<!-- Nuevo row con toggle para zodiaco sideral -->
            <div class="row mb-3">
                <div class="col-md-4">
                    <div class="form-check form-switch">
                        <input class="form-check-input" type="checkbox" id="useSiderealZodiac">
                        <label class="form-check-label" for="useSiderealZodiac">Zodiaco Sideral (Fagan-Allen, 24° 15')</label>
                    </div>
                </div>
            </div>

            <div id="transitsContainer">
                <div class="row">
                    <div class="col-md-4">
                        <div class="mb-3">
                            <label for="transitCity" class="form-label">Ciudad de Tránsito</label>
                            <input type="text" class="form-control" id="transitCity" placeholder="Ej: Madrid, España" list="transitCityList">
                            <datalist id="transitCityList"></datalist>
                        </div>
                    </div>
                    <div class="col-md-4">
                        <div class="mb-3">
                            <label for="transitDate" class="form-label">Fecha de Tránsito</label>
                            <input type="date" class="form-control" id="transitDate">
                        </div>
                    </div>
                    <div class="col-md-4">
                        <div class="mb-3">
                            <label for="transitTime" class="form-label">Hora de Tránsito</label>
                            <input type="time" class="form-control" id="transitTime">
                        </div>
                    </div>
                </div>
            </div>

            <div class="d-grid gap-2">
                <button class="btn btn-primary" id="calculateBtn">Calcular Carta Astral</button>
            </div>

            <div class="alert alert-danger mt-3 d-none" id="errorAlert" role="alert"></div>
            <div class="alert alert-info mt-3 d-none" id="infoBox">
                <span id="ascendenteInfo"></span><br>
                <span id="birthTypeInfo"></span>
            </div>
        </div>
        
        <div class="row" id="chartContent" style="display: none;">
            <!-- Rueda Zodiacal -->
            <div class="col-md-8">
                <div class="chart-container">
                    <div class="wheel-container">
                        <svg id="chartSvg" class="chart-svg" viewBox="0 0 600 600"></svg>
                        <div id="chartTooltip" class="tooltip-custom" style="display: none;"></div>
                    </div>
                </div>
                
                <!-- Sección de Predicciones -->
                <div class="predicciones-container d-none" id="prediccionesContainer">
                    <h3>Predicciones a Largo Plazo (84 años)</h3>
                    
                    <!-- Botones de puntos de referencia -->
                    <div class="mb-3" id="puntosReferenciaContainer">
                        <h5>Punto de referencia para liberaciones:</h5>
                        <div class="d-flex flex-wrap" id="puntosReferenciaBtns">
                            <!-- Los botones se generarán dinámicamente -->
                        </div>
                        <div class="punto-info" id="puntoInfo">
                            Selecciona un punto de referencia para ver la información.
                        </div>
                    </div>
                    
                    <div class="date-filter mb-3">
                        <div class="row">
                            <div class="col-md-6">
                                <label for="yearFilter" class="form-label">Filtrar por Año:</label>
                                <select class="form-select" id="yearFilter">
                                    <option value="all">Todos los años</option>
                                </select>
                            </div>
                            <div class="col-md-6">
                                <label for="tipoPrediccion" class="form-label">Tipo de Predicción:</label>
                                <select class="form-select" id="tipoPrediccion">
                                    <option value="all">Todas las predicciones</option>
                                    <option value="pico-mayor">Picos mayores</option>
                                    <option value="pico-moderado">Picos moderados</option>
                                    <option value="pico-menor">Picos menores</option>
                                    <option value="liberacion">Liberaciones</option>
                                    <option value="disolucion">Disoluciones</option>
                                </select>
                            </div>
                        </div>
                    </div>
                    
                    <div id="prediccionesList">
                        <div class="alert alert-info">Calculando predicciones...</div>
                    </div>
                </div>
            </div>
            
            <!-- Información y Coincidencias -->
            <div class="col-md-4">
                <ul class="nav nav-tabs" id="myTab" role="tablist">
                    <li class="nav-item" role="presentation">
                        <button class="nav-link active" id="planets-tab" data-bs-toggle="tab" data-bs-target="#planets" type="button" role="tab" aria-controls="planets" aria-selected="true">Planetas</button>
                    </li>
                    <li class="nav-item" role="presentation">
                        <button class="nav-link" id="aspects-tab" data-bs-toggle="tab" data-bs-target="#aspects" type="button" role="tab" aria-controls="aspects" aria-selected="false">Aspectos</button>
                    </li>
                    <li class="nav-item" role="presentation">
                        <button class="nav-link" id="advanced-tab" data-bs-toggle="tab" data-bs-target="#advanced" type="button" role="tab" aria-controls="advanced" aria-selected="false">Avanzado</button>
                    </li>
                </ul>
                <div class="tab-content" id="myTabContent">
                    <!-- Pestaña de Planetas -->
                    <div class="tab-pane fade show active" id="planets" role="tabpanel" aria-labelledby="planets-tab">
                        <h4>Carta Natal</h4>
                        <div id="natalPlanets"></div>
                        
                        <h4 class="mt-4">Tránsitos</h4>
                        <div id="transitPlanets"></div>
                    </div>
                    
                    <!-- Pestaña de Aspectos -->
                    <div class="tab-pane fade" id="aspects" role="tabpanel" aria-labelledby="aspects-tab">
                        <h4>Aspectos Internos</h4>
                        <div id="internalAspects"></div>

                        <h4 class="mt-4">Aspectos entre Cartas</h4>
                        <div id="interChartAspects"></div>
                    </div>
                    
                    <!-- Pestaña de Avanzado -->
                    <div class="tab-pane fade" id="advanced" role="tabpanel" aria-labelledby="advanced-tab">
                        <h4>Enlaces Planetarios y Disolución</h4>
                        <p>Conexiones y disoluciones de enlaces entre planetas:</p>
                        <div id="enlacesPlanetarios"></div>
                        
                        <h4 class="mt-4">Picos</h4>
                        <p>Los picos representan momentos de alta influencia planetaria:</p>
                        
                        <h5 class="mt-3">Pico Mayor</h5>
                        <div id="picoMayor"></div>
                        
                        <h5 class="mt-3">Pico Moderado</h5>
                        <div id="picoModerado"></div>
                        
                        <h5 class="mt-3">Pico Menor</h5>
                        <div id="picoMenor"></div>
                        
                        <h4 class="mt-4">Liberación de Enlace</h4>
                        <div id="liberacionEnlace"></div>
                        
                        <h4 class="mt-4">Presagios</h4>
                        <div id="presagios"></div>
                        
                        <!-- Sección Relevo Zodiacal -->
                        <div id="relevoZodiacalSection">
                            <h4 class="mt-4">Relevo Zodiacal</h4>
                            <p>Periodos y subperiodos activos en la fecha de tránsito:</p>
                            <button id="btnMostrarRelevo" class="btn btn-primary mb-3">Mostrar Relevo Zodiacal</button>
                            <div id="relevoZodiacalContainer">
                                <div class="alert alert-info">
                                Haz clic en el botón para ver el relevo zodiacal.
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Bootstrap y Librerías JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/js/bootstrap.bundle.min.js"></script>

    <!-- Script principal -->
    <script>
    document.addEventListener('DOMContentLoaded', function() {
        console.log("Script de astrología iniciado");
        
        // Constantes globales
        const DIMENSIONS = {
            centerX: 300,
            centerY: 300,
            radius: 280,
            middleRadius: 190, // Radio para la carta externa (tránsitos)
            innerRadius: 110,  // Radio para la carta interna (natal)
            glyphRadius: 265
        };

        const SIGNS = [
            {name: 'ARIES', start: 354, length: 36, symbol: '♈', color: '#FFE5E5'},
            {name: 'TAURUS', start: 30, length: 30, symbol: '♉', color: '#E5FFE5'},
            {name: 'GEMINI', start: 60, length: 30, symbol: '♊', color: '#FFFFE5'},
            {name: 'CANCER', start: 90, length: 30, symbol: '♋', color: '#E5FFFF'},
            {name: 'LEO', start: 120, length: 30, symbol: '♌', color: '#FFE5E5'},
            {name: 'VIRGO', start: 150, length: 36, symbol: '♍', color: '#E5FFE5'},
            {name: 'LIBRA', start: 186, length: 24, symbol: '♎', color: '#FFFFE5'},
            {name: 'SCORPIO', start: 210, length: 30, symbol: '♏', color: '#E5FFFF'},
            {name: 'OPHIUCHUS', start: 240, length: 12, symbol: '⛎', color: '#FFFFE5'},
            {name: 'SAGITTARIUS', start: 252, length: 18, symbol: '♐', color: '#FFE5E5'},
            {name: 'CAPRICORN', start: 270, length: 36, symbol: '♑', color: '#E5FFE5'},
            {name: 'AQUARIUS', start: 306, length: 18, symbol: '♒', color: '#FFFFE5'},
            {name: 'PEGASUS', start: 324, length: 6, symbol: '∩', color: '#E5FFFF'},
            {name: 'PISCES', start: 330, length: 24, symbol: '♓', color: '#E5FFFF'}
        ];

        const PLANET_SYMBOLS = {
            'SOL': '☉',
            'LUNA': '☽',
            'MERCURIO': '☿',
            'VENUS': '♀',
            'MARTE': '♂',
            'JÚPITER': '♃',
            'SATURNO': '♄',
            'URANO': '♅',
            'NEPTUNO': '♆',
            'PLUTÓN': '♇',
            'ASC': 'ASC',
            'MC': 'MC',
            'DSC': 'DSC',
            'IC': 'IC',
            'PARTE_FORTUNA': 'PF',
            'PARTE_ESPIRITU': 'PE'
        };

        const ASPECTS = {
            'CONJUNCTION': { angle: 0, orb: 2, color: '#000080', name: 'Armónico Relevante' },
            'SEXTILE': { angle: 60, orb: 2, color: '#000080', name: 'Armónico Relevante' },
            'SQUARE': { angle: 90, orb: 2, color: '#FF0000', name: 'Inarmónico Relevante' },
            'TRINE': { angle: 120, orb: 2, color: '#000080', name: 'Armónico Relevante' },
            'OPPOSITION': { angle: 180, orb: 2, color: '#000080', name: 'Armónico Relevante' }
        };

        const COLORS = {
            RED: '#FF0000',
            GREEN: '#00FF00',
            BLUE: '#0000FF',
            YELLOW: '#FFFF00'
        };
        
		const FIXED_STARS = [
            {
                name: "Aldebaran",
                longitude_J2000: 69.00,
                effect: "Honor, inteligencia y riqueza",
                filePath: "https://www.izarren.top/aldebaran",
                magnitude: 12
            },
            {
                name: "Antares",
                longitude_J2000: 249.18,
                effect: "Impulsividad y éxito arriesgado",
                filePath: "https://www.izarren.top/antares",
                magnitude: 12
            },
            {
                name: "Regulus",
                longitude_J2000: 148.51,
                effect: "Poder, éxito y honores",
                filePath: "https://www.izarren.top/regulus",
                magnitude: 12
            },
            {
                name: "Spica",
                longitude_J2000: 203.52,
                effect: "Beneficios a través del arte y ciencia",
                filePath: "https://www.izarren.top/spica",
                magnitude: 12
            },
            {
                name: "Sirius",
                longitude_J2000: 102.30,
                effect: "Honor, renombre y riqueza",
                filePath: "https://www.izarren.top/sirio",
                magnitude: 12
            },
            {
                name: "Algol",
                longitude_J2000: 56.3,
                effect: "Desafíos y transformación",
                filePath: "https://www.izarren.top/algol",
                magnitude: 12
            },
            {
                name: "Capella",
                longitude_J2000: 81.40,
                effect: "Honor y riqueza",
                filePath: "https://www.izarren.top/capella",
                magnitude: 12
            },
            {
                name: "Vega",
                longitude_J2000: 284.03,
                effect: "Beneficios artísticos y creatividad",
                filePath: "https://www.izarren.top/vega",
                magnitude: 12
            },
            {
                name: "Pollux",
                longitude_J2000: 113.31,
                effect: "Éxito atlético y marcial",
                filePath: "https://www.izarren.top/pollux",
                magnitude: 12
            },
            {
                name: "Fomalhaut",
                longitude_J2000: 333.0,
                effect: "Éxito espiritual y místico",
                filePath: "https://www.izarren.top/fomalhaut",
                magnitude: 6
            }
];

// Tasa de precesión anual en grados para ajustar posiciones estelares
const ANNUAL_PRECESSION_RATE = 50.2908 / 3600.0;  // Aproximadamente 50 segundos de arco por año

        const DIGNIDAD_LABELS = {
            'domicilio': 'Domicilio',
            'exaltacion': 'Exaltación',
            'peregrino': 'Peregrino',
            'caida': 'Caída',
            'exilio': 'Exilio'
        };

        // Constantes para Relevo Zodiacal
        const DURACIONES = {
            AÑO: 364,
            MES: 28,
            SEMANA: 7,
            DIA: 1
        };
        
        const DURACION_POR_NIVEL = {
            'virgo': 4, 'libra': 3, 'escorpio': 5, 'ofiuco': 7, 'sagitario': 2,
            'capricornio': 1, 'acuario': 6, 'piscis': 2, 'aries': 5, 'tauro': 3,
            'geminis': 4, 'cancer': 6, 'leo': 1
        };
        
        const SIGNOS = {
            'virgo': {'planeta': 'MERCURIO', 'años': 4},
            'libra': {'planeta': 'VENUS', 'años': 3},
            'escorpio': {'planeta': 'MARTE', 'años': 5},
            'ofiuco': {'planeta': 'SATURNO', 'años': 7},
            'sagitario': {'planeta': 'JÚPITER', 'años': 2},
            'capricornio': {'planeta': 'SOL', 'años': 1},
            'acuario': {'planeta': 'LUNA', 'años': 6},
            'piscis': {'planeta': 'JÚPITER', 'años': 2},
            'aries': {'planeta': 'MARTE', 'años': 5},
            'tauro': {'planeta': 'VENUS', 'años': 3},
            'geminis': {'planeta': 'MERCURIO', 'años': 4},
            'cancer': {'planeta': 'LUNA', 'años': 6},
            'leo': {'planeta': 'SOL', 'años': 1}
        };
        
        // Mapa de elementos para los signos
        const ELEMENTOS_SIGNOS = {
            'ARIES': {elemento: 'Fuego', color: '#ffeded', borde: '#ff5757'},
            'LEO': {elemento: 'Fuego', color: '#fff0e8', borde: '#ff7b47'},
            'SAGITTARIUS': {elemento: 'Fuego', color: '#fff5e6', borde: '#ff9933'},
            'TAURUS': {elemento: 'Tierra', color: '#f0f7e6', borde: '#7fb352'},
            'VIRGO': {elemento: 'Tierra', color: '#e8f2dc', borde: '#6b9944'},
            'CAPRICORN': {elemento: 'Tierra', color: '#f0e6d2', borde: '#b38c52'},
            'GEMINI': {elemento: 'Aire', color: '#e8f0fa', borde: '#47a0ff'},
            'LIBRA': {elemento: 'Aire', color: '#e6f2ff', borde: '#33a3ff'},
            'AQUARIUS': {elemento: 'Aire', color: '#e6f9ff', borde: '#33ccff'},
            'OPHIUCHUS': {elemento: 'Aire', color: '#e6f5ff', borde: '#4d94ff'},
            'CANCER': {elemento: 'Agua', color: '#e6e6ff', borde: '#8080ff'},
            'SCORPIO': {elemento: 'Agua', color: '#ede6ff', borde: '#9966ff'},
            'PISCES': {elemento: 'Agua', color: '#e6f2ff', borde: '#66b3ff'}
        };
        
        // Normalización de nombres de signos
        const SIGNOS_NORMALIZADOS = {
            'aries': 'ARIES',
            'tauro': 'TAURUS',
            'geminis': 'GEMINI',
            'géminis': 'GEMINI',
            'cancer': 'CANCER',
            'cáncer': 'CANCER',
            'leo': 'LEO',
            'virgo': 'VIRGO',
            'libra': 'LIBRA',
            'escorpio': 'SCORPIO',
            'ofiuco': 'OPHIUCHUS',
            'sagitario': 'SAGITTARIUS',
            'capricornio': 'CAPRICORN',
            'acuario': 'AQUARIUS',
            'piscis': 'PISCES'
        };

        // Variables globales
        let natalPlanets = [];
        let transitPlanets = [];
        let internalAspects = [];
        let interChartAspects = [];
        let enlaces = [];
        let selectedPlanet = null;
        let selectedAspect = null;
        let isDry = null;
        let ascendenteName = '';
        let birthDate = null;
		// Variables globales adicionales
        let tipoPuntoSeleccionado = 'punto'; // 'punto' para puntos de referencia, 'fardarias' para Fardarias

        
        // Variables para funcionalidad extendida
        window.pico_mayor = [];
        window.pico_moderado = [];
        window.pico_menor = [];
        window.liberacion_enlace = [];
        window.presagios = {buenos: [], malos: []};
        
        // Variables para predicciones
        let predicciones = {
            picosMayor: [],
            picosModerado: [],
            picosMenor: [],
            liberaciones: [],
            disoluciones: []
        };
        
        // Variable para puntos de referencia
        let puntosReferencia = {};
        let puntoReferenciaSeleccionado = null;

        // Elementos DOM
        const cityInput = document.getElementById('city');
        const cityList = document.getElementById('cityList');
        const dateInput = document.getElementById('date');
        const timeInput = document.getElementById('time');
        const transitCityInput = document.getElementById('transitCity');
        const transitCityList = document.getElementById('transitCityList');
        const transitDateInput = document.getElementById('transitDate');
        const transitTimeInput = document.getElementById('transitTime');
        const showTransitsToggle = document.getElementById('showTransits');
        const calculateAnalysisToggle = document.getElementById('calculateAnalysis');
        const calculatePredictionsToggle = document.getElementById('calculatePredictions');
        const transitsContainer = document.getElementById('transitsContainer');
        const calculateBtn = document.getElementById('calculateBtn');
        const chartContent = document.getElementById('chartContent');
        const chartSvg = document.getElementById('chartSvg');
        const natalPlanetsContainer = document.getElementById('natalPlanets');
        const transitPlanetsContainer = document.getElementById('transitPlanets');
        const internalAspectsContainer = document.getElementById('internalAspects');
        const interChartAspectsContainer = document.getElementById('interChartAspects');
        // Elementos DOM para análisis avanzado
        const enlacesPlanetariosContainer = document.getElementById('enlacesPlanetarios');
        const picoMayorContainer = document.getElementById('picoMayor');
        const picoModeradoContainer = document.getElementById('picoModerado');
        const picoMenorContainer = document.getElementById('picoMenor');
        const liberacionEnlaceContainer = document.getElementById('liberacionEnlace');
        const presagiosContainer = document.getElementById('presagios');
        const loadingIndicator = document.getElementById('loadingIndicator');
        const chartTooltip = document.getElementById('chartTooltip');
        const errorAlert = document.getElementById('errorAlert');
        const infoBox = document.getElementById('infoBox');
        const ascendenteInfo = document.getElementById('ascendenteInfo');
        const birthTypeInfo = document.getElementById('birthTypeInfo');
        // Elementos DOM para predicciones
        const prediccionesContainer = document.getElementById('prediccionesContainer');
        const prediccionesList = document.getElementById('prediccionesList');
        const yearFilterSelect = document.getElementById('yearFilter');
        const tipoPrediccionSelect = document.getElementById('tipoPrediccion');
        // Elementos DOM para puntos de referencia
        const puntosReferenciaContainer = document.getElementById('puntosReferenciaContainer');
        const puntosReferenciaBtns = document.getElementById('puntosReferenciaBtns');
        const puntoInfo = document.getElementById('puntoInfo');
        // Elementos DOM para Relevo Zodiacal
        const relevoZodiacalContainer = document.getElementById('relevoZodiacalContainer');
        const btnMostrarRelevo = document.getElementById('btnMostrarRelevo');
		// Añadir después de los estados existentes
        const [activeStars, setActiveStars] = React.useState([]);
        const [selectedStar, setSelectedStar] = React.useState(null);

        // Función debounce para limitar llamadas a funciones
        function debounce(func, wait) {
            let timeout;
            return function() {
                const context = this;
                const args = arguments;
                clearTimeout(timeout);
                timeout = setTimeout(() => {
                    func.apply(context, args);
                }, wait);
            };
        }

        // Función para mostrar mensajes de error
        function showError(message) {
            console.error("Error:", message);
            errorAlert.textContent = message;
            errorAlert.classList.remove('d-none');
        }

        // Función para ocultar mensajes de error
        function hideError() {
            errorAlert.textContent = '';
            errorAlert.classList.add('d-none');
        }

        // Función para mostrar tooltip
        function showTooltip(event, text) {
            chartTooltip.textContent = text;
            chartTooltip.style.display = 'block';
            
            // Posicionar el tooltip cerca del cursor
            const rect = chartSvg.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            
            chartTooltip.style.left = `${x + 15}px`;
            chartTooltip.style.top = `${y + 15}px`;
        }

        // Función para ocultar tooltip
        function hideTooltip() {
            chartTooltip.style.display = 'none';
        }

<!-- 3. Modificar la función showBirthInfo para incluir el sistema de zodiaco -->
function showBirthInfo(ascendente, esSeco) {
    ascendenteInfo.textContent = `Ascendente: ${ascendente}`;
    birthTypeInfo.textContent = `Tu nacimiento es de tipo ${esSeco ? 'seco' : 'húmedo'}`;
    
    // Agregar información sobre el sistema de zodiaco
    const useSiderealZodiac = document.getElementById('useSiderealZodiac').checked;
    const zodiacTypeInfo = document.getElementById('zodiacTypeInfo') || document.createElement('span');
    zodiacTypeInfo.id = 'zodiacTypeInfo';
    zodiacTypeInfo.textContent = `Sistema: ${useSiderealZodiac ? 'Zodiaco Sideral (Fagan-Allen, 24° 15\')' : 'Zodiaco Tropical'}`;
    
    // Si no existe el elemento, agregarlo al infoBox
    if (!document.getElementById('zodiacTypeInfo')) {
        infoBox.appendChild(document.createElement('br'));
        infoBox.appendChild(zodiacTypeInfo);
    }
    
    infoBox.classList.remove('d-none');
}

        // Función para manejar la búsqueda de ciudades - ACTUALIZADA para usar directamente Geoapify
        function handleCitySearch(searchText, isTransit) {
            const searchQuery = searchText.trim();
            const resultsContainer = isTransit ? transitCityList : cityList;
            
            if (searchQuery.length < 3) {
                resultsContainer.innerHTML = '';
                return;
            }
            
            console.log(`Buscando ciudad: ${searchQuery} (${isTransit ? 'tránsito' : 'natal'})`);
            
            // Usar directamente Geoapify en lugar del endpoint /cities
            // API Key tomada directamente del código server.py
            const API_KEY = "e19afa2a9d6643ea9550aab89eefce0b";
            const url = `https://api.geoapify.com/v1/geocode/search?text=${encodeURIComponent(searchQuery)}&apiKey=${API_KEY}`;
            
            fetch(url)
                .then(response => {
                    console.log("Respuesta de Geoapify recibida:", response.status);
                    if (!response.ok) {
                        throw new Error(`Error en la respuesta: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    console.log("Datos de ciudades:", data);
                    // Limpiar datalist
                    resultsContainer.innerHTML = '';
                    
                    // Añadir opciones
                    if (data.features && data.features.length > 0) {
                        // Convertir los resultados de Geoapify al formato esperado por la aplicación
                        const ciudades = data.features.map(feature => ({
                            nombre: feature.properties.formatted,
                            lat: feature.properties.lat,
                            lon: feature.properties.lon,
                            pais: feature.properties.country || ""
                        }));
                        
                        ciudades.forEach(ciudad => {
                            const option = document.createElement('option');
                            option.value = ciudad.nombre;
                            option.setAttribute('data-lat', ciudad.lat);
                            option.setAttribute('data-lon', ciudad.lon);
                            resultsContainer.appendChild(option);
                        });
                    } else {
                        // Ciudades de ejemplo si no hay resultados
                        const examples = [
                            { nombre: `${searchQuery}, España`, lat: 40.416, lon: -3.703 },
                            { nombre: `${searchQuery}, México`, lat: 19.432, lon: -99.133 },
                            { nombre: `${searchQuery}, Argentina`, lat: -34.603, lon: -58.381 }
                        ];
                        
                        examples.forEach(ciudad => {
                            const option = document.createElement('option');
                            option.value = ciudad.nombre;
                            option.setAttribute('data-lat', ciudad.lat);
                            option.setAttribute('data-lon', ciudad.lon);
                            resultsContainer.appendChild(option);
                        });
                    }
                })
                .catch(error => {
                    console.error('Error buscando ciudades:', error);
                    showError(`Error buscando ciudades: ${error.message}`);
                    
                    // Proporcionar algunas ciudades de ejemplo en caso de error
                    resultsContainer.innerHTML = '';
                    const examples = [
                        { nombre: "Bilbao, España", lat: 43.263, lon: -2.935 },
                        { nombre: "Madrid, España", lat: 40.416, lon: -3.703 },
                        { nombre: "Barcelona, España", lat: 41.385, lon: 2.173 },
                        { nombre: "Valencia, España", lat: 39.469, lon: -0.376 },
                        { nombre: "Sevilla, España", lat: 37.389, lon: -5.984 }                        
                    ];
                    
                    examples.forEach(ciudad => {
                        const option = document.createElement('option');
                        option.value = ciudad.nombre;
                        option.setAttribute('data-lat', ciudad.lat);
                        option.setAttribute('data-lon', ciudad.lon);
                        resultsContainer.appendChild(option);
                    });
                });
        }

// Función para mostrar/ocultar sección de tránsitos
function toggleTransits() {
    const isChecked = showTransitsToggle.checked;
    
    if (isChecked) {
        transitsContainer.style.opacity = '1';
        transitsContainer.style.pointerEvents = 'auto';
    } else {
        transitsContainer.style.opacity = '0.5';
        transitsContainer.style.pointerEvents = 'none';
    }
}

        // Función para obtener la opción seleccionada de una ciudad
        function getSelectedCityCoordinates(inputElement, datalistElement) {
            const cityValue = inputElement.value;
            
            // Buscar la opción en el datalist que coincida con el valor introducido
            for (let i = 0; i < datalistElement.options.length; i++) {
                const option = datalistElement.options[i];
                if (option.value === cityValue) {
                    return {
                        lat: parseFloat(option.getAttribute('data-lat')),
                        lon: parseFloat(option.getAttribute('data-lon'))
                    };
                }
            }
            
            // Coordenadas por defecto si no se encuentra (Madrid)
            return { lat: 40.416, lon: -3.703 };
        }

<!-- 2. Modificar la función calculateChart para incluir el parámetro de zodiaco sideral -->
function calculateChart() {
    // Validar entradas
    if (!cityInput.value || !dateInput.value || !timeInput.value) {
        showError("Debes ingresar ciudad, fecha y hora para la carta natal.");
        return;
    }
    
    if (showTransitsToggle.checked && (!transitCityInput.value || !transitDateInput.value || !transitTimeInput.value)) {
        showError("Debes ingresar ciudad, fecha y hora para los tránsitos.");
        return;
    }
    
    // Mostrar loading
    loadingIndicator.style.display = 'flex';
    hideError();
    
    // Obtener coordenadas de la ciudad seleccionada
    const natalCoords = getSelectedCityCoordinates(cityInput, cityList);
    
    console.log("Calculando carta astral...");
    console.log("Datos natal:", {
        city: cityInput.value,
        date: dateInput.value,
        time: timeInput.value,
        lat: natalCoords.lat,
        lon: natalCoords.lon
    });
    
    // Guardar fecha de nacimiento para uso posterior
    birthDate = dateInput.value;
    window.birthDate = birthDate;
    
    // Obtener el estado del toggle del zodiaco sideral
    const useSiderealZodiac = document.getElementById('useSiderealZodiac').checked;
    console.log("Usando zodiaco sideral:", useSiderealZodiac);
    
    // Calcular carta natal - Incluir coordenadas y zodiaco en la solicitud
    const natalData = {
        city: cityInput.value,
        date: dateInput.value,
        time: timeInput.value,
        lat: natalCoords.lat,
        lon: natalCoords.lon,
        calculateAnalysis: calculateAnalysisToggle.checked,
        useSidereal: useSiderealZodiac  // Agregar parámetro de zodiaco sideral
    };
    
    fetch('/calculate', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify(natalData)
    })
    .then(response => {
        console.log("Respuesta recibida:", response.status);
        return response.json();
    })
    .then(data => {
        console.log("Datos de la carta natal:", data);
        
        if (data.error) {
            throw new Error(data.error);
        }
        
        // Guardar datos básicos
        natalPlanets = data.positions;
        window.natalPlanets = natalPlanets;
        internalAspects = data.aspects;
        
        // Guardar resultados de análisis avanzado si están disponibles
        if (data.enlaces) enlaces = data.enlaces;
        if (data.pico_mayor) window.pico_mayor = data.pico_mayor;
        if (data.pico_moderado) window.pico_moderado = data.pico_moderado;
        if (data.pico_menor) window.pico_menor = data.pico_menor;
        if (data.liberacion_enlace) window.liberacion_enlace = data.liberacion_enlace;
        if (data.presagios) window.presagios = data.presagios;
        
        isDry = data.isDry;
        window.isDry = isDry;
        
        // Guardar sistema de zodiaco
        window.zodiacSystem = data.zodiacSystem || "tropical";
        
        // Mostrar información del ascendente
        const ascPlanet = natalPlanets.find(p => p.name === 'ASC');
        if (ascPlanet) {
            ascendenteName = ascPlanet.sign;
            window.ascendenteName = ascendenteName;
            showBirthInfo(ascPlanet.sign, isDry);
        }
        
        // Si hay tránsitos, calcularlos también
        if (showTransitsToggle.checked) {
            console.log("Calculando tránsitos...");
            
            // Obtener coordenadas de la ciudad de tránsito
            const transitCoords = getSelectedCityCoordinates(transitCityInput, transitCityList);
            
            console.log("Datos tránsito:", {
                city: transitCityInput.value,
                date: transitDateInput.value,
                time: transitTimeInput.value,
                lat: transitCoords.lat,
                lon: transitCoords.lon
            });
            
            fetch('/calculate', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    city: transitCityInput.value,
                    date: transitDateInput.value,
                    time: transitTimeInput.value,
                    lat: transitCoords.lat,
                    lon: transitCoords.lon,
                    calculateAnalysis: calculateAnalysisToggle.checked,
                    useSidereal: useSiderealZodiac  // Agregar parámetro de zodiaco sideral
                })
            })
            .then(transitResponse => {
                console.log("Respuesta de tránsitos recibida:", transitResponse.status);
                return transitResponse.json();
            })
            .then(transitData => {
                console.log("Datos de tránsitos:", transitData);
                
                if (transitData.error) {
                    throw new Error(transitData.error);
                }
                
                transitPlanets = transitData.positions;
                
                // Calcular aspectos entre cartas
                interChartAspects = calculateAspects(natalPlanets, transitPlanets);
                
                // Renderizar carta completa
                renderChart();
                
                // Calcular predicciones si está activado
                if (calculatePredictionsToggle.checked) {
                    calculatePredictions();
                }
            })
            .catch(error => {
                console.error('Error calculando tránsitos:', error);
                showError("Error calculando tránsitos: " + error.message);
                loadingIndicator.style.display = 'none';
            });
        } else {
            transitPlanets = [];
            interChartAspects = [];
            renderChart();
            
            // Calcular predicciones si está activado
            if (calculatePredictionsToggle.checked) {
                calculatePredictions();
            }
        }
    })
    .catch(error => {
        console.error('Error calculando carta:', error);
        showError("Error calculando carta: " + error.message);
        loadingIndicator.style.display = 'none';
    });
}

React.useEffect(() => {
    if (planets.length > 0) {
        const updatedStars = FIXED_STARS.map(star => {
            const currentLongitude = getCurrentStarPosition(star, date);
            const sign = getSign(currentLongitude);
            const conjunctPlanets = findConjunctPlanets(star, planets, date);
            
            return {
                ...star,
                longitude: currentLongitude,
                sign: sign,
                conjunctPlanets: conjunctPlanets,
                selected: star.name === selectedStar,
                isActive: conjunctPlanets.length > 0
            };
        }).filter(star => star.isActive);
        
        setActiveStars(updatedStars);
    }
}, [planets, date, selectedStar]);

// Función para calcular la posición actual de una estrella
function getCurrentStarPosition(star, dateStr) {
    // Tasa de precesión anual en grados para ajustar posiciones estelares
    const ANNUAL_PRECESSION_RATE = 50.2908 / 3600.0; // Aproximadamente 50 segundos de arco por año
    
    // Convertir fecha a objeto Date
    const currentDate = new Date(dateStr);
    // Calcular año decimal
    const year = currentDate.getFullYear() + (currentDate.getMonth() + 1) / 12;
    // Años desde J2000
    const yearsSinceJ2000 = year - 2000.0;
    // Calcular precesión
    const precession = ANNUAL_PRECESSION_RATE * yearsSinceJ2000;
    // Devolver longitud ajustada
    return (star.longitude_J2000 + precession) % 360;
}

// Función para encontrar planetas en conjunción con una estrella
function findConjunctPlanets(star, planetsList, dateStr) {
    const currentLongitude = getCurrentStarPosition(star, dateStr);
    const orb = star.magnitude >= 12 ? 2.40 : 1.20;
    
    return planetsList.filter(planet => {
        const diff = Math.abs(currentLongitude - planet.longitude);
        const adjustedDiff = Math.min(diff, 360 - diff);
        return adjustedDiff <= orb;
    }).map(planet => ({
        name: planet.name,
        diff: Math.min(
            Math.abs(currentLongitude - planet.longitude),
            360 - Math.abs(currentLongitude - planet.longitude)
        ).toFixed(2)
    }));
}

function handleStarClick(starName) {
    setSelectedStar(selectedStar === starName ? null : starName);
    setSelectedPlanet(null);
    setSelectedAspect(null);
}

        // Función para calcular predicciones a largo plazo - ACTUALIZADA
        function calculatePredictions() {
            console.log("Calculando predicciones a largo plazo...");
            
            // Mostrar contenedor de predicciones
            prediccionesContainer.classList.remove('d-none');
            prediccionesList.innerHTML = '<div class="alert alert-info">Calculando predicciones... Esto puede tardar unos momentos.</div>';
            
            // Preparar datos para enviar - incluir datos completos
            const predictionsData = {
                birthDate: birthDate,
                isDry: isDry,
                ascendente: ascendenteName,
                // Si no enviamos start/end year, el servidor usa por defecto el rango completo de 84 años
                startYear: null, 
                endYear: null,
                puntoReferencia: puntoReferenciaSeleccionado,  // Enviar el punto de referencia seleccionado
                cartaNatal: natalPlanets // Incluir la carta natal completa
            };
            
            // Llamada al servidor para calcular predicciones
            fetch('/calculate_forecasts', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(predictionsData)
            })
            .then(response => {
                console.log("Respuesta de predicciones recibida:", response.status);
                return response.json();
            })
            .then(data => {
                console.log("Predicciones recibidas:", data);
                
                if (data.error) {
                    throw new Error(data.error);
                }
                
                // Guardar predicciones
                predicciones.picosMayor = data.picos?.mayor || [];
                predicciones.picosModerado = data.picos?.moderado || [];
                predicciones.picosMenor = data.picos?.menor || [];
                predicciones.liberaciones = data.liberaciones || [];
                predicciones.disoluciones = data.disoluciones || [];
                
                // Guardar información de puntos de referencia
                if (data.puntos_referencia) {
                    puntosReferencia = data.puntos_referencia;
                    // Generar botones para puntos de referencia
                    generarBotonesPuntosReferencia();
                }
                
                // Generar lista de años para el filtro
                generateYearOptions();
                
                // Mostrar predicciones
                renderPredictions();
            })
            .catch(error => {
                console.error('Error calculando predicciones:', error);
                prediccionesList.innerHTML = `
                    <div class="alert alert-warning">
                        <h5>Error al calcular predicciones</h5>
                        <p>${error.message}</p>
                        <p>Las predicciones requieren que el servidor esté configurado correctamente.</p>
                    </div>
                `;
                
                // Al menos crear los botones de puntos de referencia por si fallan las predicciones
                if (Object.keys(puntosReferencia).length === 0) {
                    puntosReferencia = {
                        "ASCENDENTE": {
                            "descripcion": "Punto de la carta que representa el inicio de la primera casa."
                        },
                        "PARTE_FORTUNA": {
                            "descripcion": "Punto calculado en base a las posiciones del Sol, la Luna y el Ascendente."
                        },
                        "PARTE_ESPIRITU": {
                            "descripcion": "Punto inverso a la Parte de Fortuna, representa la conciencia y el espíritu."
                        }
                    };
                    generarBotonesPuntosReferencia();
                }
            });
        }

// Función para actualizar la información del punto seleccionado
function actualizarInfoPunto() {
    if (tipoPuntoSeleccionado === 'fardarias') {
        puntoInfo.innerHTML = `
            <strong>Fardarias</strong>: 
            Este sistema divide la vida en períodos y subperíodos regidos por diferentes planetas según su orden en la secta diurna o nocturna.
        `;
    } else if (puntoReferenciaSeleccionado && puntosReferencia[puntoReferenciaSeleccionado]) {
        const info = puntosReferencia[puntoReferenciaSeleccionado];
        puntoInfo.innerHTML = `
            <strong>${puntoReferenciaSeleccionado.replace('_', ' ').replace(/\b\w/g, l => l.toUpperCase())}</strong>: 
            ${info.descripcion}
        `;
    } else {
        puntoInfo.innerHTML = 'Se mostrarán liberaciones desde todos los puntos de referencia.';
    }
}

function generarBotonesPuntosReferencia() {
    console.log("Generando botones de puntos de referencia");
    
    // Limpiar contenedor de botones
    puntosReferenciaBtns.innerHTML = '';
    
    // Añadir botón "Fardarias" como único botón general
    const btnFardarias = document.createElement('button');
    btnFardarias.type = 'button';
    btnFardarias.className = `btn btn-outline-info punto-referencia-btn ${tipoPuntoSeleccionado === 'fardarias' ? 'active' : ''}`;
    btnFardarias.dataset.punto = '';
    btnFardarias.dataset.tipo = 'fardarias'; // Identificador específico para Fardarias
    btnFardarias.textContent = 'Fardarias';
    btnFardarias.addEventListener('click', function() {
        console.log("Botón Fardarias clickeado");
        seleccionarPuntoReferencia('', 'fardarias');
    });
    puntosReferenciaBtns.appendChild(btnFardarias);
    
    // Añadir botones para cada punto de referencia específico
    for (const [punto, info] of Object.entries(puntosReferencia)) {
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = `btn btn-outline-primary punto-referencia-btn ${puntoReferenciaSeleccionado === punto && tipoPuntoSeleccionado === 'punto' ? 'active' : ''}`;
        btn.dataset.punto = punto;
        btn.dataset.tipo = 'punto'; // Tipo normal - punto de referencia
        btn.textContent = punto.replace('_', ' ').replace(/\b\w/g, l => l.toUpperCase());
        btn.addEventListener('click', function() {
            console.log(`Botón ${punto} clickeado`);
            seleccionarPuntoReferencia(punto, 'punto');
        });
        puntosReferenciaBtns.appendChild(btn);
    }
    
    // Mostrar información del punto seleccionado
    actualizarInfoPunto();
    
    console.log("Botones generados:", puntosReferenciaBtns.children.length);
}

// Función para mostrar Fardarias en la pestaña Avanzado
function mostrarFardariasEnAvanzado() {
    console.log("Iniciando mostrarFardariasEnAvanzado");
    
    // Primero, asegurarnos de que tenemos los datos necesarios
    if (!birthDate || isDry === null) {
        console.error("No hay suficientes datos para calcular Fardarias");
        return;
    }

    // Activar la pestaña Avanzado primero
    const advancedTab = document.getElementById('advanced-tab');
    if (advancedTab) {
        advancedTab.click();
        console.log("Pestaña Avanzado activada");
    } else {
        console.error("No se encontró la pestaña Avanzado");
    }

    // Crear contenedor para Fardarias si no existe
    let fardariasContainer = document.getElementById('fardariasContainer');
    if (!fardariasContainer) {
        // Buscar una ubicación adecuada para insertar el contenedor
        const relevoZodiacalSection = document.getElementById('relevoZodiacalSection');
        if (relevoZodiacalSection) {
            fardariasContainer = document.createElement('div');
            fardariasContainer.id = 'fardariasContainer';
            relevoZodiacalSection.parentNode.insertBefore(fardariasContainer, relevoZodiacalSection.nextSibling);
            console.log("Contenedor de Fardarias creado");
        } else {
            // Si no encontramos el contenedor de relevo, intentar con el contenedor avanzado
            const advancedContainer = document.getElementById('advanced');
            if (advancedContainer) {
                fardariasContainer = document.createElement('div');
                fardariasContainer.id = 'fardariasContainer';
                advancedContainer.appendChild(fardariasContainer);
                console.log("Contenedor de Fardarias creado en tab avanzado");
            } else {
                console.error("No se pudo encontrar un lugar para insertar el contenedor de Fardarias");
                return;
            }
        }
    }

    // Preparar contenedor con título
    fardariasContainer.innerHTML = `
        <h4 class="mt-4">Fardarias Activas</h4>
        <p>Sistema tradicional de períodos planetarios basado en la secta (diurna/nocturna).</p>
        <div id="fardariasContent" class="loading-container">
            <div class="spinner-border text-primary" role="status">
                <span class="visually-hidden">Calculando...</span>
            </div>
            <p>Calculando periodos de Fardarias...</p>
        </div>
    `;

    // Calcular Fardarias mediante una llamada al servidor
    const transitDate = transitDateInput ? transitDateInput.value : new Date().toISOString().split('T')[0];
    
    console.log("Solicitando Fardarias para fecha:", transitDate);
    
    fetch('/calculate_forecasts', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({
            birthDate: birthDate,
            isDry: isDry,
            ascendente: ascendenteName,
            startYear: null,
            endYear: null,
            puntoReferencia: null,
            calculoFardarias: true, // Agregar flag específico para solicitar fardarias
            cartaNatal: natalPlanets
        })
    })
    .then(response => {
        console.log("Respuesta del servidor recibida:", response.status);
        return response.json();
    })
    .then(data => {
        console.log("Datos de Fardarias recibidos:", data);
        
        if (data.error) {
            throw new Error(data.error);
        }
        
        // Mostrar Fardarias
        if (data.fardarias && data.fardarias.length > 0) {
            mostrarPeriodosFardariasActivos(data.fardarias, transitDate);
        } else {
            document.getElementById('fardariasContent').innerHTML = `
                <div class="alert alert-info">
                    No se encontraron datos de Fardarias para la fecha seleccionada.
                </div>
            `;
        }
    })
    .catch(error => {
        console.error('Error calculando Fardarias:', error);
        document.getElementById('fardariasContent').innerHTML = `
            <div class="alert alert-warning">
                <h5>Error al calcular Fardarias</h5>
                <p>${error.message}</p>
                <p>Verifica que el servidor esté configurado correctamente para calcular Fardarias.</p>
            </div>
        `;
    });
}

// Función corregida para mostrar exactamente el período de Fardarias para la fecha seleccionada
function mostrarPeriodosFardariasActivos(periodos, fechaTransito) {
    const fardariasContent = document.getElementById('fardariasContent');
    
    if (!fardariasContent) {
        console.error("No se encontró el contenedor de contenido de Fardarias");
        return;
    }
    
    if (!periodos || periodos.length === 0) {
        fardariasContent.innerHTML = '<div class="alert alert-info">No se encontraron periodos de Fardarias activos.</div>';
        return;
    }
    
    // Asegurar que fechaTransito es un objeto Date
    let fechaTransitoDt;
    if (typeof fechaTransito === 'string') {
        // Intentar parsear la fecha de diferentes formatos
        if (fechaTransito.includes('-')) {
            // Formato ISO (YYYY-MM-DD)
            fechaTransitoDt = new Date(fechaTransito);
        } else if (fechaTransito.includes('/')) {
            // Formato europeo (DD/MM/YYYY)
            const parts = fechaTransito.split('/');
            if (parts.length === 3) {
                fechaTransitoDt = new Date(parseInt(parts[2]), parseInt(parts[1]) - 1, parseInt(parts[0]));
            } else {
                fechaTransitoDt = new Date(fechaTransito);
            }
        } else {
            fechaTransitoDt = new Date(fechaTransito);
        }
    } else if (fechaTransito instanceof Date) {
        fechaTransitoDt = fechaTransito;
    } else {
        // Si no podemos parsear la fecha, usar la fecha actual
        fechaTransitoDt = new Date();
        console.warn("No se pudo parsear la fecha de tránsito, usando fecha actual");
    }
    
    // Formatear fecha para registro
    const fechaStr = fechaTransitoDt.toLocaleDateString('es-ES', {
        day: '2-digit',
        month: '2-digit',
        year: 'numeric'
    });
    
    console.log("Mostrando Fardarias activas para fecha:", fechaStr);
    
    // Función mejorada para analizar fechas desde varios formatos
    function parseDate(dateString) {
        if (!dateString) return null;
        
        let date;
        
        try {
            // Primero intentar con formato ISO (YYYY-MM-DD)
            date = new Date(dateString);
            
            // Si falla, intentar con formato europeo (DD/MM/YYYY)
            if (isNaN(date.getTime()) && dateString.includes('/')) {
                const parts = dateString.split('/');
                if (parts.length === 3) {
                    // Formato europeo: día/mes/año
                    date = new Date(
                        parseInt(parts[2]),  // año
                        parseInt(parts[1]) - 1,  // mes (0-11)
                        parseInt(parts[0])   // día
                    );
                }
            }
            
            // Si sigue fallando, intentar otros formatos...
            if (isNaN(date.getTime())) {
                // Intentar formato con texto de mes en español
                const monthNames = {
                    'enero': 0, 'febrero': 1, 'marzo': 2, 'abril': 3, 'mayo': 4, 'junio': 5,
                    'julio': 6, 'agosto': 7, 'septiembre': 8, 'octubre': 9, 'noviembre': 10, 'diciembre': 11
                };
                
                // Buscar patrones como "02 de enero de 2024"
                const regex = /(\d{1,2}) de (\w+) de (\d{4})/;
                const match = dateString.match(regex);
                if (match) {
                    const day = parseInt(match[1]);
                    const month = monthNames[match[2].toLowerCase()];
                    const year = parseInt(match[3]);
                    
                    if (!isNaN(day) && month !== undefined && !isNaN(year)) {
                        date = new Date(year, month, day);
                    }
                }
            }
            
            // Si todas las conversiones fallan, devolver null
            if (isNaN(date.getTime())) {
                console.error("No se pudo parsear la fecha:", dateString);
                return null;
            }
            
            return date;
        } catch (e) {
            console.error("Error al parsear fecha:", dateString, e);
            return null;
        }
    }
    
    // Comprobar si una fecha está en un rango
    function estaEnRango(fecha, inicio, fin) {
        return fecha >= inicio && fecha <= fin;
    }
    
    // Obtener un identificador único para una fecha (para depuración)
    function getDateId(date) {
        return `${date.getFullYear()}-${(date.getMonth() + 1).toString().padStart(2, '0')}-${date.getDate().toString().padStart(2, '0')}`;
    }
    
    // Buscar período exacto para la fecha de tránsito
    function encontrarPeriodoExacto(periodos, fecha) {
        for (const periodo of periodos) {
            try {
                const fechaInicio = parseDate(periodo.start);
                const fechaFin = parseDate(periodo.end);
                
                if (!fechaInicio || !fechaFin) continue;
                
                if (estaEnRango(fecha, fechaInicio, fechaFin)) {
                    return periodo;
                }
            } catch (e) {
                console.error("Error al procesar periodo:", e);
            }
        }
        return null;
    }
    
    // Buscar nivel 1 (período principal)
    const periodoNivel1 = encontrarPeriodoExacto(periodos, fechaTransitoDt);
    
    if (!periodoNivel1) {
        console.warn("No se encontró período de nivel 1 para la fecha:", fechaStr);
        fardariasContent.innerHTML = '<div class="alert alert-warning">No se encontró un período de Fardarias para la fecha seleccionada.</div>';
        return;
    }
    
    console.log("Período nivel 1 encontrado:", periodoNivel1.planet);
    
    // Buscar nivel 2 (subperíodo)
    let periodoNivel2 = null;
    if (periodoNivel1.subPeriods && periodoNivel1.subPeriods.length > 0) {
        periodoNivel2 = encontrarPeriodoExacto(periodoNivel1.subPeriods, fechaTransitoDt);
    }
    
    // Buscar nivel 3 (sub-subperíodo)
    let periodoNivel3 = null;
    if (periodoNivel2 && periodoNivel2.subPeriods && periodoNivel2.subPeriods.length > 0) {
        periodoNivel3 = encontrarPeriodoExacto(periodoNivel2.subPeriods, fechaTransitoDt);
    }
    
    // Buscar nivel 4 (diario)
    let periodoNivel4 = null;
    if (periodoNivel3 && periodoNivel3.subPeriods && periodoNivel3.subPeriods.length > 0) {
        periodoNivel4 = encontrarPeriodoExacto(periodoNivel3.subPeriods, fechaTransitoDt);
    }
    
    // Log para depuración
    console.log("Estructura de períodos encontrados:");
    console.log("- Nivel 1:", periodoNivel1 ? periodoNivel1.planet : "No encontrado");
    console.log("- Nivel 2:", periodoNivel2 ? periodoNivel2.planet : "No encontrado");
    console.log("- Nivel 3:", periodoNivel3 ? periodoNivel3.planet : "No encontrado");
    console.log("- Nivel 4:", periodoNivel4 ? periodoNivel4.planet : "No encontrado");
    
    // Si no se encuentra un nivel específico, buscamos el período más cercano
    if (!periodoNivel2 && periodoNivel1.subPeriods && periodoNivel1.subPeriods.length > 0) {
        // Ordenar por fecha de inicio
        const subperiodosOrdenados = [...periodoNivel1.subPeriods].sort((a, b) => {
            const fechaInicioA = parseDate(a.start);
            const fechaInicioB = parseDate(b.start);
            if (!fechaInicioA || !fechaInicioB) return 0;
            return Math.abs(fechaInicioA - fechaTransitoDt) - Math.abs(fechaInicioB - fechaTransitoDt);
        });
        
        periodoNivel2 = subperiodosOrdenados[0];
        console.log("Usando subperíodo más cercano:", periodoNivel2.planet);
    }
    
    if (!periodoNivel3 && periodoNivel2 && periodoNivel2.subPeriods && periodoNivel2.subPeriods.length > 0) {
        // Ordenar por fecha de inicio
        const subsubperiodosOrdenados = [...periodoNivel2.subPeriods].sort((a, b) => {
            const fechaInicioA = parseDate(a.start);
            const fechaInicioB = parseDate(b.start);
            if (!fechaInicioA || !fechaInicioB) return 0;
            return Math.abs(fechaInicioA - fechaTransitoDt) - Math.abs(fechaInicioB - fechaTransitoDt);
        });
        
        periodoNivel3 = subsubperiodosOrdenados[0];
        console.log("Usando sub-subperíodo más cercano:", periodoNivel3.planet);
    }
    
    if (!periodoNivel4 && periodoNivel3 && periodoNivel3.subPeriods && periodoNivel3.subPeriods.length > 0) {
        // Ordenar por fecha de inicio
        const nivel4Ordenados = [...periodoNivel3.subPeriods].sort((a, b) => {
            const fechaInicioA = parseDate(a.start);
            const fechaInicioB = parseDate(b.start);
            if (!fechaInicioA || !fechaInicioB) return 0;
            return Math.abs(fechaInicioA - fechaTransitoDt) - Math.abs(fechaInicioB - fechaTransitoDt);
        });
        
        periodoNivel4 = nivel4Ordenados[0];
        console.log("Usando período nivel 4 más cercano:", periodoNivel4.planet);
    }
    
    // Crear HTML para mostrar Fardarias
    let html = `
        <div class="fardaria-periodo periodo-activo" style="border-left: 4px solid #0d6efd; padding: 10px; margin-bottom: 15px; background-color: #f8f9fa;">
            <h5>
                Período de ${periodoNivel1.planet || 'Planeta no especificado'}
                <span class="badge bg-success">Período Actual</span>
            </h5>
            <p>
                Desde ${formatearFechaLocal(periodoNivel1.start)} hasta ${formatearFechaLocal(periodoNivel1.end)}
            </p>
    `;
    
    // Añadir nivel 2 si existe
    if (periodoNivel2) {
        html += `
            <div class="fardaria-subperiodo periodo-activo" style="margin-left: 20px; border-left: 4px solid #0d6efd; padding-left: 10px;">
                <h6>
                    Subperíodo de ${periodoNivel2.planet || 'Planeta no especificado'}
                    <span class="badge bg-success">Subperíodo Actual</span>
                </h6>
                <p>
                    Desde ${formatearFechaLocal(periodoNivel2.start)} hasta ${formatearFechaLocal(periodoNivel2.end)}
                </p>
        `;
        
        // Añadir nivel 3 si existe
        if (periodoNivel3) {
            html += `
                <div class="fardaria-subsubperiodo periodo-activo" style="margin-left: 20px; border-left: 4px solid #6610f2; padding-left: 10px;">
                    <h6>
                        Sub-subperíodo de ${periodoNivel3.planet || 'Planeta no especificado'}
                        <span class="badge bg-success">Activo</span>
                    </h6>
                    <p>
                        Desde ${formatearFechaLocal(periodoNivel3.start)} hasta ${formatearFechaLocal(periodoNivel3.end)}
                    </p>
            `;
            
            // Añadir nivel 4 si existe
            if (periodoNivel4) {
                html += `
                    <div class="fardaria-nivel4 periodo-activo" style="margin-left: 40px; border-left: 4px solid #d63384; padding-left: 10px;">
                        <h6>
                            Nivel 4 de ${periodoNivel4.planet || 'Planeta no especificado'}
                            <span class="badge bg-success">Activo</span>
                        </h6>
                        <p>
                            Desde ${formatearFechaLocal(periodoNivel4.start)} hasta ${formatearFechaLocal(periodoNivel4.end)}
                        </p>
                    </div>
                `;
            }
            
            html += `</div>`;
        }
        
        html += `</div>`;
    }
    
    html += `</div>`;
    
    // Añadir información sobre la interpretación de Fardarias
    html += `
        <div class="mt-3">
            <h5>Interpretación de Fardarias</h5>
            <p>Las Fardarias son un sistema antiguo de períodos planetarios que se calculan según el orden de los planetas en la secta diurna o nocturna. 
               Cada planeta gobierna un período de tiempo y tiene sub-períodos regidos por otros planetas. Los períodos de Fardarias indican áreas de enfoque y 
               temas predominantes en diferentes etapas de la vida.</p>
            
            <div class="card mt-2">
                <div class="card-header">
                    <strong>Orden de planetas según secta</strong>
                </div>
                <div class="card-body">
                    <p><strong>Secta Diurna (nacimiento seco):</strong> Sol, Marte, Júpiter, Saturno, Luna, Mercurio, Venus</p>
                    <p><strong>Secta Nocturna (nacimiento húmedo):</strong> Luna, Mercurio, Venus, Sol, Marte, Júpiter, Saturno</p>
                </div>
            </div>
        </div>
    `;
    
    // Botón para depuración detallada
    if (transitDateInput && transitDateInput.value) {
        html += `
            <div class="mt-3">
                <button class="btn btn-sm btn-outline-secondary" onclick="debugFardarias()">
                    Depurar Fardarias
                </button>
                <small class="text-muted ms-2">Fecha de tránsito: ${fechaStr}</small>
            </div>
        `;
    }
    
    fardariasContent.innerHTML = html;
    console.log("Contenido de Fardarias mostrado correctamente");
}

// Añadir función auxiliar para depuración
function debugFardarias() {
    console.group("Depuración de Fardarias");
    console.log("Fecha de tránsito seleccionada:", transitDateInput ? transitDateInput.value : "No disponible");
    console.log("Fecha de nacimiento:", birthDate || "No disponible");
    console.log("Tipo de nacimiento:", isDry ? "Seco" : "Húmedo");
    
    // Intentar acceder a los datos de Fardarias
    if (window.fardariasData) {
        console.log("Datos de Fardarias disponibles:", window.fardariasData);
        
        // Intentar parsear las fechas de todos los niveles
        try {
            const parseDate = function(dateString) {
                if (!dateString) return null;
                
                // Varios intentos de parseo
                try {
                    // ISO
                    let date = new Date(dateString);
                    if (!isNaN(date.getTime())) return date;
                    
                    // Formato europeo DD/MM/YYYY
                    if (dateString.includes('/')) {
                        const parts = dateString.split('/');
                        if (parts.length === 3) {
                            date = new Date(parseInt(parts[2]), parseInt(parts[1]) - 1, parseInt(parts[0]));
                            if (!isNaN(date.getTime())) return date;
                        }
                    }
                    
                    // Formato con texto
                    const monthNames = {
                        'enero': 0, 'febrero': 1, 'marzo': 2, 'abril': 3, 'mayo': 4, 'junio': 5,
                        'julio': 6, 'agosto': 7, 'septiembre': 8, 'octubre': 9, 'noviembre': 10, 'diciembre': 11
                    };
                    
                    const regex = /(\d{1,2}) de (\w+) de (\d{4})/;
                    const match = dateString.match(regex);
                    if (match) {
                        const day = parseInt(match[1]);
                        const month = monthNames[match[2].toLowerCase()];
                        const year = parseInt(match[3]);
                        
                        if (!isNaN(day) && month !== undefined && !isNaN(year)) {
                            return new Date(year, month, day);
                        }
                    }
                    
                    return null;
                } catch (e) {
                    console.error("Error al parsear fecha:", dateString, e);
                    return null;
                }
            };
            
            // Función para analizar un nivel
            const analizarNivel = function(periodos, nivel) {
                console.group(`Nivel ${nivel}`);
                
                periodos.forEach((periodo, index) => {
                    const fechaInicio = parseDate(periodo.start);
                    const fechaFin = parseDate(periodo.end);
                    
                    console.log(`Período ${index + 1} (${periodo.planet}):`, 
                        fechaInicio ? fechaInicio.toISOString() : "Fecha inválida",
                        "-",
                        fechaFin ? fechaFin.toISOString() : "Fecha inválida"
                    );
                    
                    if (periodo.subPeriods && periodo.subPeriods.length > 0) {
                        analizarNivel(periodo.subPeriods, nivel + 1);
                    }
                });
                
                console.groupEnd();
            };
            
            // Analizar todos los niveles
            analizarNivel(window.fardariasData, 1);
            
        } catch (e) {
            console.error("Error al analizar datos de Fardarias:", e);
        }
    } else {
        console.log("No hay datos de Fardarias disponibles globalmente");
    }
    
    console.groupEnd();
}

// Función auxiliar para formatear fechas en formato local
function formatearFechaLocal(fechaStr) {
    try {
        const fecha = new Date(fechaStr);
        if (isNaN(fecha)) {
            return fechaStr; // Si no se puede convertir, devolver la cadena original
        }
        return fecha.toLocaleDateString('es-ES', {
            day: '2-digit',
            month: 'long',
            year: 'numeric'
        });
    } catch (e) {
        console.error("Error formateando fecha:", e);
        return fechaStr;
    }
}

// Añadir estas funciones de depuración
function debugFardarias() {
    // Función auxiliar para depuración que podemos llamar en la consola
    console.log("------------ Depuración de Fardarias ------------");
    console.log("Estado global:");
    console.log("- tipoPuntoSeleccionado:", tipoPuntoSeleccionado);
    console.log("- puntoReferenciaSeleccionado:", puntoReferenciaSeleccionado);
    console.log("- birthDate:", birthDate);
    console.log("- isDry:", isDry);
    console.log("- ascendenteName:", ascendenteName);
    
    console.log("\nElementos DOM:");
    console.log("- Pestaña Avanzado:", document.getElementById('advanced-tab'));
    console.log("- Botones de puntos de referencia:", document.querySelectorAll('.punto-referencia-btn').length);
    console.log("- Contenedor de Fardarias:", document.getElementById('fardariasContainer'));
    console.log("- Sección de Relevo Zodiacal:", document.getElementById('relevoZodiacalSection'));
    
    // Verificar si podemos acceder a la pestaña Avanzado
    const advancedTab = document.getElementById('advanced-tab');
    if (advancedTab) {
        console.log("La pestaña Avanzado existe y podemos acceder a ella");
    } else {
        console.error("No se puede encontrar la pestaña Avanzado");
    }
    
    console.log("-------------------------------------------------");
}

// Versión corregida de la función seleccionarPuntoReferencia
function seleccionarPuntoReferencia(punto, tipo = 'punto') {
    console.log(`Seleccionando punto de referencia: ${punto}, tipo: ${tipo}`);
    
    // Actualizar variables globales
    puntoReferenciaSeleccionado = punto;
    tipoPuntoSeleccionado = tipo; // Variable global para el tipo
    
    // Actualizar estado de botones
    document.querySelectorAll('.punto-referencia-btn').forEach(btn => {
        if ((btn.dataset.punto === punto && btn.dataset.tipo === tipo) || 
            (punto === '' && btn.dataset.tipo === tipo)) {
            btn.classList.add('active');
        } else {
            btn.classList.remove('active');
        }
    });
    
    // Actualizar información del punto seleccionado
    actualizarInfoPunto();
    
    // Si es tipo fardarias, mostrar información en pestaña Avanzado
    if (tipo === 'fardarias') {
        console.log("Mostrando Fardarias en pestaña Avanzado");
        // Activar explícitamente la pestaña Avanzado
        const advancedTab = document.getElementById('advanced-tab');
        if (advancedTab && typeof advancedTab.click === 'function') {
            advancedTab.click();
            setTimeout(() => {
                mostrarFardariasEnAvanzado();
            }, 500); // Pequeño retraso para asegurar que la pestaña esté activada
        } else {
            console.error("No se pudo hacer clic en la pestaña Avanzado");
            mostrarFardariasEnAvanzado();
        }
    } else {
        // Recalcular predicciones con el nuevo punto de referencia
        calculatePredictions();
    }
}



        // Función para generar opciones de años para el filtro
        function generateYearOptions() {
            // Limpiar el select
            yearFilterSelect.innerHTML = '<option value="all">Todos los años</option>';
            
            // Recopilar todas las fechas de las predicciones
            const allDates = [
                ...predicciones.picosMayor.map(p => p.fecha),
                ...predicciones.picosModerado.map(p => p.fecha),
                ...predicciones.picosMenor.map(p => p.fecha),
                ...predicciones.liberaciones.map(p => p.fecha),
                ...predicciones.disoluciones.map(p => p.fecha)
            ];
            
            // Extraer los años únicos
            const years = new Set();
            allDates.forEach(fecha => {
                const year = fecha.split('-')[0];
                years.add(year);
            });
            
            // Ordenar años numéricamente
            const sortedYears = Array.from(years).sort((a, b) => parseInt(a) - parseInt(b));
            
            // Agregar opciones al select
            sortedYears.forEach(year => {
                const option = document.createElement('option');
                option.value = year;
                option.textContent = year;
                yearFilterSelect.appendChild(option);
            });
        }

        // Función para renderizar predicciones
        function renderPredictions() {
            // Actualizar también la función para renderizar el contenido de las predicciones
    if (tipoPuntoSeleccionado === 'fardarias') {
        // Si estamos en modo Fardarias, no mostramos predicciones normales
        prediccionesList.innerHTML = `
            <div class="alert alert-info">
                <h5>Modo Fardarias activo</h5>
                <p>Las predicciones se muestran en la pestaña "Avanzado".</p>
                <button class="btn btn-primary" id="verFardariasBtn">Ver Fardarias</button>
            </div>
        `;
        
        // Añadir evento al botón
        const verFardariasBtn = document.getElementById('verFardariasBtn');
        if (verFardariasBtn) {
            verFardariasBtn.addEventListener('click', function() {
                document.getElementById('advanced-tab').click();
            });
        }
        
        return;
    }

            // Obtener filtros seleccionados
            const yearFilter = yearFilterSelect.value;
            const tipoFilter = tipoPrediccionSelect.value;
            
            // Recopilar todas las predicciones
            let allPredictions = [];
            
            // Picos Mayores
            if (tipoFilter === 'all' || tipoFilter === 'pico-mayor') {
                predicciones.picosMayor.forEach(pico => {
                    allPredictions.push({
                        fecha: pico.fecha,
                        tipo: 'pico-mayor',
                        descripcion: `Pico Mayor: ${pico.planeta} con fuerza ${pico.fuerza}`,
                        planeta: pico.planeta,
                        fuerza: pico.fuerza,
                        punto: pico.punto,
                        angulo: pico.angulo
                    });
                });
            }
            
            // Picos Moderados
            if (tipoFilter === 'all' || tipoFilter === 'pico-moderado') {
                predicciones.picosModerado.forEach(pico => {
                    allPredictions.push({
                        fecha: pico.fecha,
                        tipo: 'pico-moderado',
                        descripcion: `Pico Moderado: ${pico.planeta} con fuerza ${pico.fuerza}`,
                        planeta: pico.planeta,
                        fuerza: pico.fuerza,
                        punto: pico.punto,
                        angulo: pico.angulo
                    });
                });
            }
            
            // Picos Menores
            if (tipoFilter === 'all' || tipoFilter === 'pico-menor') {
                predicciones.picosMenor.forEach(pico => {
                    allPredictions.push({
                        fecha: pico.fecha,
                        tipo: 'pico-menor',
                        descripcion: `Pico Menor: ${pico.planeta} con fuerza ${pico.fuerza}`,
                        planeta: pico.planeta,
                        fuerza: pico.fuerza,
                        punto: pico.punto,
                        angulo: pico.angulo
                    });
                });
            }
            
            // Liberaciones
            if (tipoFilter === 'all' || tipoFilter === 'liberacion') {
                predicciones.liberaciones.forEach(lib => {
                    allPredictions.push({
                        fecha: lib.fecha,
                        tipo: 'liberacion',
                        descripcion: `Liberación: ${lib.planeta_liberador} libera a ${lib.planeta_liberado} (${lib.punto})`,
                        planeta_liberador: lib.planeta_liberador,
                        planeta_liberado: lib.planeta_liberado,
                        condicion: lib.condicion,
                        punto: lib.punto,
                        angulo: lib.angulo
                    });
                });
            }
            
            // Disoluciones
            if (tipoFilter === 'all' || tipoFilter === 'disolucion') {
                predicciones.disoluciones.forEach(dis => {
                    allPredictions.push({
                        fecha: dis.fecha,
                        tipo: 'disolucion',
                        descripcion: `Disolución: enlace entre ${dis.planeta1} y ${dis.planeta2}`,
                        planeta1: dis.planeta1,
                        planeta2: dis.planeta2
                    });
                });
            }
            
            // Filtrar por año si es necesario
            if (yearFilter !== 'all') {
                allPredictions = allPredictions.filter(pred => pred.fecha.startsWith(yearFilter));
            }
            
            // Ordenar por fecha
            allPredictions.sort((a, b) => (a.fecha > b.fecha) ? 1 : -1);
            
            // Mostrar resultados
            if (allPredictions.length === 0) {
                prediccionesList.innerHTML = '<div class="alert alert-info">No hay predicciones que coincidan con los filtros seleccionados.</div>';
                return;
            }
            
            // Agrupar por año
            const predictionsByYear = {};
            allPredictions.forEach(pred => {
                const year = pred.fecha.split('-')[0];
                if (!predictionsByYear[year])
                    predictionsByYear[year] = [];
                predictionsByYear[year].push(pred);
            });
            
            // Generar HTML
            let html = '';
            Object.keys(predictionsByYear).sort().forEach(year => {
                html += `
                    <div class="year-group" data-year="${year}">
                        <div class="year-header" onclick="toggleYearGroup('${year}')">
                            ${year} <span class="badge bg-primary">${predictionsByYear[year].length}</span> <span class="float-end">▼</span>
                        </div>
                        <div class="year-content" id="year-content-${year}">
                `;
                
                predictionsByYear[year].forEach(pred => {
                    const date = new Date(pred.fecha);
                    const formattedDate = date.toLocaleDateString('es-ES', { 
                        day: '2-digit', 
                        month: 'long'
                    });
                    
                    // Añadimos más detalles a la descripción cuando tenemos ángulos
                    let detalles = '';
                    if (pred.punto && pred.angulo) {
                        detalles = ` (${pred.punto}, ángulo ${pred.angulo}°)`;
                    }
                    
                    html += `
                        <div class="prediccion-item prediccion-${pred.tipo}" data-fecha="${pred.fecha}" onclick="showTransitForDate('${pred.fecha}')">
                            <div class="prediccion-fecha">${formattedDate}</div>
                            <div>${pred.descripcion}${detalles}</div>
                        </div>
                    `;
                });
                
                html += `
                        </div>
                    </div>
                `;
            });
            
            prediccionesList.innerHTML = html;
            
            // Expandir el primer año por defecto
            const firstYearContent = document.getElementById(`year-content-${Object.keys(predictionsByYear).sort()[0]}`);
            if (firstYearContent) {
                firstYearContent.style.display = 'block';
            }
        }

        // Función para expandir/contraer grupos de años
        function toggleYearGroup(year) {
            const yearContent = document.getElementById(`year-content-${year}`);
            if (yearContent) {
                yearContent.style.display = yearContent.style.display === 'block' ? 'none' : 'block';
                
                // Actualizar el ícono
                const yearHeader = document.querySelector(`.year-group[data-year="${year}"] .year-header span.float-end`);
                if (yearHeader) {
                    yearHeader.textContent = yearContent.style.display === 'block' ? '▼' : '▶';
                }
            }
        }

        // Función para mostrar tránsitos para una fecha específica
        function showTransitForDate(fecha) {
            // Asegurarse de que tenemos una ciudad para los tránsitos
            if (!transitCityInput.value) {
                transitCityInput.value = cityInput.value; // Usar la misma ciudad que la carta natal
            }
            
            // Actualizar campos de fecha y hora de tránsito
            transitDateInput.value = fecha;
            transitTimeInput.value = '12:00'; // Usar mediodía por defecto
            
            // Activar el toggle de tránsitos si no está activo
            if (!showTransitsToggle.checked) {
                showTransitsToggle.checked = true;
                toggleTransits();
            }
            
            // Asegurarse que el análisis avanzado está activado
            if (!calculateAnalysisToggle.checked) {
                calculateAnalysisToggle.checked = true;
            }
            
            // Calcular tránsitos para esta fecha
            const transitCoords = getSelectedCityCoordinates(transitCityInput, transitCityList);
            
            // Mostrar loading
            loadingIndicator.style.display = 'flex';
            
            fetch('/calculate', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    city: transitCityInput.value,
                    date: fecha,
                    time: transitTimeInput.value,
                    lat: transitCoords.lat,
                    lon: transitCoords.lon,
                    calculateAnalysis: true // Siempre calcular análisis avanzado para los tránsitos
                })
            })
            .then(response => response.json())
            .then(data => {
                console.log("Datos de tránsito para fecha específica:", data);
                
                if (data.error) {
                    throw new Error(data.error);
                }
                
                // Actualizar tránsitos
                transitPlanets = data.positions;
                
                // Calcular aspectos entre cartas
                interChartAspects = calculateAspects(natalPlanets, transitPlanets);
                
                // Renderizar carta
                renderChart();
                
                // Hacer scroll hacia la carta
                chartContent.scrollIntoView({ behavior: 'smooth' });
            })
            .catch(error => {
                console.error('Error calculando tránsitos para fecha específica:', error);
                showError(`Error calculando tránsitos: ${error.message}`);
                loadingIndicator.style.display = 'none';
            });
        }

        // Función para calcular aspectos entre planetas
        function calculateAspects(planets1, planets2) {
            // Filtrar planetas tradicionales
            const traditionalPlanets = ["SOL", "LUNA", "MERCURIO", "VENUS", "MARTE", "JÚPITER", "SATURNO"];
            const validPlanets1 = planets1.filter(p => traditionalPlanets.includes(p.name));
            const validPlanets2 = planets2.filter(p => traditionalPlanets.includes(p.name));
            
            const aspects = [];
            const isSameChart = planets1 === planets2;
            
            for (let i = 0; i < validPlanets1.length; i++) {
                // Si es la misma carta, evitar aspectos duplicados
                const startJ = isSameChart ? i + 1 : 0;
                
                for (let j = startJ; j < validPlanets2.length; j++) {
                    const planet1 = validPlanets1[i];
                    const planet2 = validPlanets2[j];
                    
                    if (planet1 === planet2) continue;
                    
                    let diff = Math.abs(planet1.longitude - planet2.longitude);
                    if (diff > 180) diff = 360 - diff;
                    
                    // Comprobar aspectos importantes
                    for (const aspectType in ASPECTS) {
                        const aspect = ASPECTS[aspectType];
                        
                        if (Math.abs(diff - aspect.angle) <= aspect.orb) {
                            aspects.push({
                                planet1: planet1.name,
                                planet2: planet2.name,
                                type: aspectType,
                                angle: diff,
                                color: aspect.color,
                                isInterChart: !isSameChart,
                                fuerza: 0 // Se calculará en el backend si está disponible
                            });
                            break;
                        }
                    }
                }
            }
            
            return aspects;
        }

// Modificación para renderChart
function renderChart() {
    console.log("Renderizando carta astral...");
    
    // Limpiar SVG
    chartSvg.innerHTML = '';
    
    // Dibujar elementos
    drawZodiacWheel();
    drawAspects();
    
    // AÑADIR AQUÍ: Dibujar estrellas fijas
    if (activeStars && activeStars.length > 0) {
        drawFixedStars();
    }
    
    drawPlanets(natalPlanets, true);
    
    if (showTransitsToggle.checked && transitPlanets.length > 0) {
        drawPlanets(transitPlanets, false);
    }
    
    // Actualizar listas de información
    updatePlanetsList();
    updateAspectsList();
    updateAdvancedInfo();
    
    // AÑADIR AQUÍ: Renderizar componente de estrellas fijas
    renderFixedStarsComponent();
    
    // Mostrar la carta
    chartContent.style.display = 'flex';
    
    // Ocultar loading
    loadingIndicator.style.display = 'none';
    
    console.log("Carta astral renderizada");
}

function drawFixedStars() {
    // Limpiar estrellas existentes
    const existingStarsGroup = document.querySelector('.fixed-stars-group');
    if (existingStarsGroup) {
        existingStarsGroup.remove();
    }
    
    // Verificar si tenemos los datos necesarios
    if (!activeStars || !chartSvg) return;
    
    // Crear un grupo para todos los elementos de estrellas
    const starsGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    starsGroup.setAttribute('class', 'fixed-stars-group');
    
    // Dibujar cada estrella
    activeStars.forEach((star) => {
        // Calcular posición en la carta
        const starAngle = ((star.longitude - 90) * Math.PI) / 180;
        
        // Posicionar estrellas entre los círculos exterior y medio
        const radius = DIMENSIONS.radius - 20; // Ligeramente dentro de la rueda exterior
        
        const x = DIMENSIONS.centerX + radius * Math.cos(starAngle);
        const y = DIMENSIONS.centerY + radius * Math.sin(starAngle);
        
        // Dibujar punto de estrella
        const starPoint = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        starPoint.setAttribute('cx', x);
        starPoint.setAttribute('cy', y);
        starPoint.setAttribute('r', star.magnitude >= 12 ? '4' : '3');
        starPoint.setAttribute('fill', '#FFD700');
        starPoint.setAttribute('stroke', '#000');
        starPoint.setAttribute('stroke-width', selectedStar === star.name ? '2' : '0.5');
        starPoint.setAttribute('class', `star-point ${selectedStar === star.name ? 'selected' : ''}`);
        starPoint.setAttribute('data-star-name', star.name);
        
        // Agregar evento de clic
        starPoint.addEventListener('click', () => {
            handleStarClick(star.name);
        });
        
        // Agregar punto de estrella al grupo
        starsGroup.appendChild(starPoint);
        
        // Para estrella seleccionada o estrellas muy brillantes, agregar una pequeña etiqueta
        if (selectedStar === star.name || star.magnitude >= 12) {
            const labelX = DIMENSIONS.centerX + (radius + 12) * Math.cos(starAngle);
            const labelY = DIMENSIONS.centerY + (radius + 12) * Math.sin(starAngle);
            
            const starLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            starLabel.setAttribute('x', labelX);
            starLabel.setAttribute('y', labelY);
            starLabel.setAttribute('text-anchor', 'middle');
            starLabel.setAttribute('alignment-baseline', 'middle');
            starLabel.setAttribute('font-size', '8');
            starLabel.setAttribute('font-weight', 'bold');
            starLabel.setAttribute('class', 'star-label');
            starLabel.textContent = star.name.split(' ')[0]; // Solo la primera palabra
            
            starsGroup.appendChild(starLabel);
        }
    });
    
    // Agregar el grupo de estrellas al SVG principal
    chartSvg.appendChild(starsGroup);
}

function renderFixedStarsComponent() {
    // Buscar o crear contenedor
    let starsContainer = document.getElementById('fixedStarsContainer');
    
    if (!starsContainer) {
        // Crear contenedor si no existe
        const advancedTab = document.getElementById('advanced-tab');
        if (advancedTab) {
            // Añadir como nueva pestaña
            const tabsNav = advancedTab.parentElement.parentElement;
            
            // Crear pestaña de estrellas
            const starsTab = document.createElement('li');
            starsTab.className = 'nav-item';
            starsTab.setAttribute('role', 'presentation');
            starsTab.innerHTML = `
                <button class="nav-link" id="stars-tab" data-bs-toggle="tab" 
                        data-bs-target="#stars" type="button" role="tab" 
                        aria-controls="stars" aria-selected="false">Estrellas Fijas</button>
            `;
            
            tabsNav.appendChild(starsTab);
            
            // Crear contenido de pestaña
            const tabContent = document.getElementById('myTabContent');
            const starsPane = document.createElement('div');
            starsPane.className = 'tab-pane fade';
            starsPane.id = 'stars';
            starsPane.setAttribute('role', 'tabpanel');
            starsPane.setAttribute('aria-labelledby', 'stars-tab');
            
            // Crear contenedor de estrellas dentro de pestaña
            starsContainer = document.createElement('div');
            starsContainer.id = 'fixedStarsContainer';
            
            starsPane.appendChild(starsContainer);
            tabContent.appendChild(starsPane);
        } else {
            // Fallback: añadir después del contenido existente
            const chartContent = document.getElementById('chartContent');
            if (chartContent) {
                starsContainer = document.createElement('div');
                starsContainer.id = 'fixedStarsContainer';
                starsContainer.className = 'col-md-12 mt-4';
                chartContent.appendChild(starsContainer);
            }
        }
    }
    
    if (!starsContainer || !activeStars) {
        return;
    }
    
    // Generar HTML para estrellas fijas
    let starsHtml = `
        <div class="fixed-stars-container">
            <h3>Estrellas Fijas ${selectedPlanet ? `en conjunción con ${selectedPlanet}` : ''}</h3>
    `;
    
    if (!activeStars || activeStars.length === 0) {
        starsHtml += `<p>No hay datos de estrellas fijas disponibles para esta carta.</p>`;
    } else {
        starsHtml += `
            <div class="stars-list">
        `;
        
        // Filtrar estrellas si un planeta está seleccionado
        const displayedStars = selectedPlanet 
            ? activeStars.filter(star => star.conjunctPlanets && star.conjunctPlanets.some(p => p.name === selectedPlanet))
            : activeStars;
            
        if (displayedStars.length === 0) {
            starsHtml += `<p>No hay estrellas en conjunción con ${selectedPlanet}.</p>`;
        } else {
            displayedStars.forEach(star => {
                starsHtml += `
                    <div class="star-item ${star.name === selectedStar ? 'selected' : ''}" 
                        data-star-name="${star.name}" onclick="handleStarClick('${star.name}')">
                        <div class="star-header">
                            <span class="star-symbol">★</span>
                            <strong>${star.name}</strong> - ${star.sign} (${star.longitude.toFixed(2)}°)
                        </div>
                        
                        <div class="star-details">
                            <div>
                                <strong>Conjunción con:</strong> ${
                                    star.conjunctPlanets && star.conjunctPlanets.map(p => 
                                        `${PLANET_SYMBOLS[p.name] || p.name} (${p.diff}°)`
                                    ).join(', ')
                                }
                            </div>
                            <div><strong>Efecto:</strong> ${star.effect}</div>
                            <div><strong>Enlace:</strong> <a href="${star.filePath}" class="star-link" target="_blank" onclick="event.stopPropagation();">${star.name}</a></div>
                        </div>
                    </div>
                `;
            });
        }
        
        starsHtml += `</div>`;
    }
    
    starsHtml += `</div>`;
    starsContainer.innerHTML = starsHtml;
}

function handleStarClick(starName) {
    // Comprobar si es la misma estrella (conmutar selección)
    selectedStar = selectedStar === starName ? null : starName;
    
    // Limpiar selecciones de planetas y aspectos
    selectedPlanet = null;
    selectedAspect = null;
    
    // Volver a renderizar la carta
    renderChart();
}

        // Función para dibujar la rueda zodiacal
        function drawZodiacWheel() {
            // Dibujar círculo exterior
            const outerCircle = createSvgElement('circle', {
                cx: DIMENSIONS.centerX,
                cy: DIMENSIONS.centerY,
                r: DIMENSIONS.radius,
                fill: 'none',
                stroke: '#333',
                'stroke-width': 2
            });
            chartSvg.appendChild(outerCircle);
            
            // Dibujar signos zodiacales
            SIGNS.forEach(sign => {
                const midAngle = ((sign.start + sign.length/2 - 90) * Math.PI) / 180;
                const glyphX = DIMENSIONS.centerX + DIMENSIONS.glyphRadius * Math.cos(midAngle);
                const glyphY = DIMENSIONS.centerY + DIMENSIONS.glyphRadius * Math.sin(midAngle);
                
                // Dibujar sector
                const path = createSvgElement('path', {
                    d: createArcPath(sign.start, sign.start + sign.length),
                    fill: sign.color,
                    stroke: '#333',
                    'stroke-width': 1
                });
                chartSvg.appendChild(path);
                
                // Añadir símbolo
                const text = createSvgElement('text', {
                    x: glyphX,
                    y: glyphY,
                    'text-anchor': 'middle',
                    'alignment-baseline': 'middle',
                    'font-size': 20
                });
                text.textContent = sign.symbol;
                chartSvg.appendChild(text);
            });
            
            // Dibujar círculo interior
            const innerCircle = createSvgElement('circle', {
                cx: DIMENSIONS.centerX,
                cy: DIMENSIONS.centerY,
                r: DIMENSIONS.innerRadius,
                fill: 'white',
                stroke: '#333',
                'stroke-width': 1
            });
            chartSvg.appendChild(innerCircle);
        }

        // Función para dibujar aspectos
        function drawAspects() {
            // Dibujar aspectos internos
            internalAspects.forEach((aspect, index) => {
                const planet1 = natalPlanets.find(p => p.name === aspect.planet1);
                const planet2 = natalPlanets.find(p => p.name === aspect.planet2);
                
                if (!planet1 || !planet2) return;
                
                const angle1 = (planet1.longitude - 90) * Math.PI / 180;
                const angle2 = (planet2.longitude - 90) * Math.PI / 180;
                
                const x1 = DIMENSIONS.centerX + DIMENSIONS.innerRadius * Math.cos(angle1);
                const y1 = DIMENSIONS.centerY + DIMENSIONS.innerRadius * Math.sin(angle1);
                const x2 = DIMENSIONS.centerX + DIMENSIONS.innerRadius * Math.cos(angle2);
                const y2 = DIMENSIONS.centerY + DIMENSIONS.innerRadius * Math.sin(angle2);
                
                const line = createSvgElement('line', {
                    x1: x1,
                    y1: y1,
                    x2: x2,
                    y2: y2,
                    stroke: aspect.color,
                    'stroke-width': selectedAspect === aspect ? '3' : '1',
                    'data-aspect-index': index,
                    'class': 'aspect-line internal-aspect'
                });
                
                line.addEventListener('click', () => {
                    selectAspect(aspect, 'internal');
                });
                
                line.addEventListener('mouseover', (e) => {
                    const aspectName = ASPECTS[aspect.type]?.name || aspect.type;
                    showTooltip(e, `${aspect.planet1} ${aspectName} ${aspect.planet2} (${aspect.angle.toFixed(1)}°)`);
                });
                
                line.addEventListener('mouseout', () => {
                    hideTooltip();
                });
                
                chartSvg.appendChild(line);
            });
            
            // Dibujar aspectos entre cartas
            if (showTransitsToggle.checked && transitPlanets.length > 0) {
                interChartAspects.forEach((aspect, index) => {
                    const planet1 = natalPlanets.find(p => p.name === aspect.planet1);
                    const planet2 = transitPlanets.find(p => p.name === aspect.planet2);
                    
                    if (!planet1 || !planet2) return;
                    
                    const angle1 = (planet1.longitude - 90) * Math.PI / 180;
                    const angle2 = (planet2.longitude - 90) * Math.PI / 180;
                    
                    const x1 = DIMENSIONS.centerX + DIMENSIONS.innerRadius * Math.cos(angle1);
                    const y1 = DIMENSIONS.centerY + DIMENSIONS.innerRadius * Math.sin(angle1);
                    const x2 = DIMENSIONS.centerX + DIMENSIONS.middleRadius * Math.cos(angle2);
                    const y2 = DIMENSIONS.centerY + DIMENSIONS.middleRadius * Math.sin(angle2);
                    
                    const line = createSvgElement('line', {
                        x1: x1,
                        y1: y1,
                        x2: x2,
                        y2: y2,
                        stroke: aspect.color,
                        'stroke-width': selectedAspect === aspect ? '3' : '1',
                        'stroke-dasharray': '3,3',
                        'data-aspect-index': index,
                        'class': 'aspect-line inter-aspect'
                    });
                    
                    line.addEventListener('click', () => {
                        selectAspect(aspect, 'inter');
                    });
                    
                    line.addEventListener('mouseover', (e) => {
                        const aspectName = ASPECTS[aspect.type]?.name || aspect.type;
                        showTooltip(e, `${aspect.planet1} ${aspectName} ${aspect.planet2} (${aspect.angle.toFixed(1)}°)`);
                    });
                    
                    line.addEventListener('mouseout', () => {
                        hideTooltip();
                    });
                    
                    chartSvg.appendChild(line);
                });
            }
        }

        // Función para determinar si un color es claro u oscuro
        function isLightColor(color) {
            // Si es un color en formato hexadecimal como "#RRGGBB"
            if (typeof color === 'string' && color.startsWith('#')) {
                const r = parseInt(color.slice(1, 3), 16);
                const g = parseInt(color.slice(3, 5), 16);
                const b = parseInt(color.slice(5, 7), 16);
                
                // Fórmula para calcular la luminosidad percibida
                // basada en recomendaciones de WCAG: https://www.w3.org/TR/WCAG20/
                const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
                
                // Si la luminosidad es mayor a 0.5, consideramos el color como claro
                return luminance > 0.5;
            }
            
            // Para los colores predefinidos en COLORS
            if (color === COLORS.YELLOW || color === COLORS.GREEN) {
                return true; // Amarillo y verde son colores claros
            }
            
            return false; // Por defecto, consideramos el color como oscuro
        }

// Función para dibujar planetas
function drawPlanets(planets, isNatal) {
    const radius = isNatal ? DIMENSIONS.innerRadius : DIMENSIONS.middleRadius;
    
    // Define pastel colors
    const PASTEL_COLORS = {
        RED: '#FF9999',       // Pastel red
        GREEN: '#99FF99',     // Pastel green
        BLUE: '#9999FF',      // Pastel blue
        YELLOW: '#FFFF99',    // Pastel yellow
        ORANGE: '#FFD699',    // Pastel orange
        PURPLE: '#D699FF',    // Pastel purple
        CYAN: '#99FFFF',      // Pastel cyan
        PINK: '#FF99FF',      // Pastel pink
        GRAY: '#E0E0E0'       // Light gray for cardinal points
    };
    
    planets.forEach((planet, index) => {
        // Calculate position on the circle
        const angle = (planet.longitude - 90) * Math.PI / 180;
        const x = DIMENSIONS.centerX + radius * Math.cos(angle);
        const y = DIMENSIONS.centerY + radius * Math.sin(angle);
        
        // Assign pastel colors
        let planetColor;
        const longitude = planet.longitude;
        
        // Color logic using pastel tones
        if (planet.name === 'ASC' || planet.name === 'MC' || planet.name === 'DSC' || planet.name === 'IC' ||
            planet.name === 'PARTE_FORTUNA' || planet.name === 'PARTE_ESPIRITU') {
            planetColor = PASTEL_COLORS.GRAY;  // Light gray for cardinal points
        } else if (planet.name === 'JÚPITER') {
            if ((longitude >= 306.00 && longitude <= 360.00) || (longitude >= 0.00 && longitude <= 150.00)) 
                planetColor = PASTEL_COLORS.BLUE;
            else if (longitude > 150.00 && longitude < 306.00) 
                planetColor = PASTEL_COLORS.RED;
            else
                planetColor = PASTEL_COLORS.BLUE;
        } else if (planet.name === 'SATURNO') {
            if ((longitude >= 330.00 && longitude <= 360.00) || (longitude >= 0.00 && longitude <= 150.00))
                planetColor = PASTEL_COLORS.YELLOW;
            else if (longitude > 240.00 && longitude <= 252.00) 
                planetColor = PASTEL_COLORS.YELLOW;
            else if (longitude > 252.00 && longitude <= 330.00) 
                planetColor = PASTEL_COLORS.RED;
            else if (longitude > 150.00 && longitude <= 240.00) 
                planetColor = PASTEL_COLORS.RED;
            else
                planetColor = PASTEL_COLORS.YELLOW;
        } else if (longitude > 150.00 && longitude <= 330.00) {
            if (planet.name === 'SOL' || planet.name === 'MERCURIO' || planet.name === 'URANO')
                planetColor = PASTEL_COLORS.GREEN;
            else if (planet.name === 'VENUS' || planet.name === 'LUNA')
                planetColor = PASTEL_COLORS.YELLOW;
            else if (planet.name === 'MARTE' || planet.name === 'PLUTÓN')
                planetColor = PASTEL_COLORS.BLUE;
            else if (planet.name === 'NEPTUNO')
                planetColor = PASTEL_COLORS.RED;
            else
                planetColor = PASTEL_COLORS.GRAY;
        } else {
            if (planet.name === 'SOL' || planet.name === 'MARTE' || planet.name === 'PLUTÓN')
                planetColor = PASTEL_COLORS.RED;
            else if (planet.name === 'VENUS')
                planetColor = PASTEL_COLORS.GREEN;
            else if (planet.name === 'MERCURIO' || planet.name === 'URANO')
                planetColor = PASTEL_COLORS.YELLOW;
            else if (planet.name === 'LUNA' || planet.name === 'NEPTUNO')
                planetColor = PASTEL_COLORS.BLUE;
            else
                planetColor = PASTEL_COLORS.GRAY;
        }
        
        // Create circle for the planet
        const circle = createSvgElement('circle', {
            cx: x,
            cy: y,
            r: 12,
            fill: planetColor, // Use pastel color
            stroke: selectedPlanet === planet ? '#0000FF' : '#000000',
            'stroke-width': selectedPlanet === planet ? 3 : 1,
            'data-planet-index': index,
            'data-is-natal': isNatal,
            'class': 'planet-symbol'
        });
        
        // Add events to the circle
        circle.addEventListener('click', () => {
            selectPlanet(planet, isNatal);
        });
        
        circle.addEventListener('mouseover', (e) => {
            // Add retrograde status to tooltip if applicable
            let retroInfo = '';
            if (planet.motion_status === 'retrograde') {
                retroInfo = ' (Retrógrado)';
            } else if (planet.motion_status === 'stationary_retrograde') {
                retroInfo = ' (Estacionario Retrógrado)';
            } else if (planet.motion_status === 'stationary_direct') {
                retroInfo = ' (Estacionario Directo)';
            }
            
            showTooltip(e, `${planet.name}${retroInfo} en ${planet.sign} (${planet.longitude.toFixed(1)}°)`);
        });
        
        circle.addEventListener('mouseout', () => {
            hideTooltip();
        });
        
        chartSvg.appendChild(circle);
        
        // For retrograde planets, add a visual indicator
        if (planet.motion_status === 'retrograde' || 
            planet.motion_status === 'stationary_retrograde' || 
            planet.motion_status === 'stationary_direct') {
            
            // Add a small indicator for retrograde motion
            const retroIndicator = createSvgElement('circle', {
                cx: x,
                cy: y - 10, // Position above the planet
                r: 3,
                fill: planet.motion_status === 'retrograde' ? '#dc3545' : 
                     planet.motion_status === 'stationary_retrograde' ? '#fd7e14' : '#20c997',
                'pointer-events': 'none'
            });
            
            chartSvg.appendChild(retroIndicator);
        }
        
        // Determine text style based on the planet
        // Venus and Mars in bold, rest normal
        if (planet.name === 'VENUS' || planet.name === 'MARTE') {
            // For Venus and Mars apply a stronger bold effect
            // First draw a thick outline
            const textOutline = createSvgElement('text', {
                x: x,
                y: y,
                'text-anchor': 'middle',
                'alignment-baseline': 'middle',
                'font-size': 14,
                'fill': '#000000',
                'stroke': '#000000', 
                'stroke-width': 1,  // Thicker outline for Venus and Mars
                'font-weight': 'bold',
                'pointer-events': 'none'
            });
            textOutline.textContent = PLANET_SYMBOLS[planet.name] || planet.name;
            chartSvg.appendChild(textOutline);
            
            // And then the main text on top for a stronger effect
            const textMain = createSvgElement('text', {
                x: x,
                y: y,
                'text-anchor': 'middle',
                'alignment-baseline': 'middle',
                'font-size': 14,
                'fill': '#000000',
                'font-weight': 'bold',
                'pointer-events': 'none'
            });
            textMain.textContent = PLANET_SYMBOLS[planet.name] || planet.name;
            chartSvg.appendChild(textMain);
        } else {
            // For other planets, normal text without additional bold effect
            const text = createSvgElement('text', {
                x: x,
                y: y,
                'text-anchor': 'middle',
                'alignment-baseline': 'middle',
                'font-size': 14,
                'fill': '#000000',
                'font-weight': 'bold',  // Already has normal bold
                'pointer-events': 'none'
            });
            text.textContent = PLANET_SYMBOLS[planet.name] || planet.name;
            chartSvg.appendChild(text);
        }
    });
}
        
        // Función para crear un elemento SVG
        function createSvgElement(type, attributes = {}) {
            const element = document.createElementNS('http://www.w3.org/2000/svg', type);
            
            for (const [key, value] of Object.entries(attributes)) {
                element.setAttribute(key, value);
            }
            
            return element;
        }

        // Función para crear un path de arco SVG
        function createArcPath(startAngle, endAngle) {
            // Convertir ángulos a radianes
            const startRad = (startAngle - 90) * Math.PI / 180;
            const endRad = (endAngle - 90) * Math.PI / 180;
            
            // Calcular puntos
            const startX = DIMENSIONS.centerX + DIMENSIONS.radius * Math.cos(startRad);
            const startY = DIMENSIONS.centerY + DIMENSIONS.radius * Math.sin(startRad);
            const endX = DIMENSIONS.centerX + DIMENSIONS.radius * Math.cos(endRad);
            const endY = DIMENSIONS.centerY + DIMENSIONS.radius * Math.sin(endRad);
            
            // Determinar flag de arco grande
            const largeArcFlag = endAngle - startAngle <= 180 ? '0' : '1';
            
            // Construir el string del path
            return `M ${DIMENSIONS.centerX} ${DIMENSIONS.centerY} L ${startX} ${startY} A ${DIMENSIONS.radius} ${DIMENSIONS.radius} 0 ${largeArcFlag} 1 ${endX} ${endY} Z`;
        }

// Función para actualizar la lista de planetas
function updatePlanetsList() {
    // Update natal planets list
    natalPlanetsContainer.innerHTML = '';
    
    natalPlanets.forEach(planet => {
        const planetItem = document.createElement('div');
        planetItem.className = `planet-list-item ${selectedPlanet === planet ? 'selected' : ''}`;
        
        // Determine CSS class for dignity
        let dignityClass = '';
        if (planet.dignidad) {
            dignityClass = `dignity-${planet.dignidad}`;
        }
        
        // Determine retrograde symbol
        let retroSymbol = '';
        if (planet.motion_status === 'retrograde') {
            retroSymbol = ' <span class="retrograde">℞</span>'; // Rx symbol
        } else if (planet.motion_status === 'stationary_retrograde') {
            retroSymbol = ' <span class="stationary-retrograde">Sr</span>'; // Sr symbol
        } else if (planet.motion_status === 'stationary_direct') {
            retroSymbol = ' <span class="stationary-direct">Sd</span>'; // Sd symbol
        }
        
        planetItem.innerHTML = `
            <strong>${PLANET_SYMBOLS[planet.name] || planet.name}</strong>${retroSymbol}: 
            ${planet.sign} ${planet.longitude.toFixed(1)}° 
            <span class="${dignityClass}">${planet.dignidad ? `(${DIGNIDAD_LABELS[planet.dignidad]})` : ''}</span>
        `;
        
        planetItem.addEventListener('click', () => {
            selectPlanet(planet, true);
        });
        
        natalPlanetsContainer.appendChild(planetItem);
    });
    
    // Update transit planets list
    transitPlanetsContainer.innerHTML = '';
    
    if (showTransitsToggle.checked && transitPlanets.length > 0) {
        transitPlanets.forEach(planet => {
            const planetItem = document.createElement('div');
            planetItem.className = `planet-list-item ${selectedPlanet === planet ? 'selected' : ''}`;
            
            // Determine CSS class for dignity
            let dignityClass = '';
            if (planet.dignidad) {
                dignityClass = `dignity-${planet.dignidad}`;
            }
            
            // Determine retrograde symbol
            let retroSymbol = '';
            if (planet.motion_status === 'retrograde') {
                retroSymbol = ' <span class="retrograde">℞</span>'; // Rx symbol
            } else if (planet.motion_status === 'stationary_retrograde') {
                retroSymbol = ' <span class="stationary-retrograde">Sr</span>'; // Sr symbol
            } else if (planet.motion_status === 'stationary_direct') {
                retroSymbol = ' <span class="stationary-direct">Sd</span>'; // Sd symbol
            }
            
            planetItem.innerHTML = `
                <strong>${PLANET_SYMBOLS[planet.name] || planet.name}</strong>${retroSymbol}: 
                ${planet.sign} ${planet.longitude.toFixed(1)}° 
                <span class="${dignityClass}">${planet.dignidad ? `(${DIGNIDAD_LABELS[planet.dignidad]})` : ''}</span>
            `;
            
            planetItem.addEventListener('click', () => {
                selectPlanet(planet, false);
            });
            
            transitPlanetsContainer.appendChild(planetItem);
        });
    } else {
        transitPlanetsContainer.innerHTML = '<p>No hay datos de tránsitos.</p>';
    }
}

        // Función para actualizar la lista de aspectos
        function updateAspectsList() {
            // Actualizar aspectos internos
            internalAspectsContainer.innerHTML = '';
            
            if (internalAspects.length > 0) {
                internalAspects.forEach(aspect => {
                    const aspectItem = document.createElement('div');
                    aspectItem.className = `aspect-list-item ${selectedAspect === aspect ? 'selected' : ''}`;
                    
                    const aspectName = ASPECTS[aspect.type]?.name || aspect.type;
                    const aspectStrength = aspect.fuerza ? ` (Fuerza: ${aspect.fuerza.toFixed(1)})` : '';
                    
                    aspectItem.innerHTML = `
                        <strong>${PLANET_SYMBOLS[aspect.planet1] || aspect.planet1}</strong> 
                        <span style="color: ${ASPECTS[aspect.type].color};">${aspectName}</span> 
                        <strong>${PLANET_SYMBOLS[aspect.planet2] || aspect.planet2}</strong>
                        ${aspectStrength}
                    `;
                    
                    aspectItem.addEventListener('click', () => {
                        selectAspect(aspect, 'internal');
                    });
                    
                    internalAspectsContainer.appendChild(aspectItem);
                });
            } else {
                internalAspectsContainer.innerHTML = '<p>No hay aspectos internos.</p>';
            }
            
            // Actualizar aspectos entre cartas
            interChartAspectsContainer.innerHTML = '';
            
            if (showTransitsToggle.checked && interChartAspects.length > 0) {
                interChartAspects.forEach(aspect => {
                    const aspectItem = document.createElement('div');
                    aspectItem.className = `aspect-list-item ${selectedAspect === aspect ? 'selected' : ''}`;
                    
                    const aspectName = ASPECTS[aspect.type]?.name || aspect.type;
                    
                    aspectItem.innerHTML = `
                        <strong>${PLANET_SYMBOLS[aspect.planet1] || aspect.planet1}</strong> (natal)
                        <span style="color: ${ASPECTS[aspect.type].color};">${aspectName}</span> 
                        <strong>${PLANET_SYMBOLS[aspect.planet2] || aspect.planet2}</strong> (tránsito)
                    `;
                    
                    aspectItem.addEventListener('click', () => {
                        selectAspect(aspect, 'inter');
                    });
                    
                    interChartAspectsContainer.appendChild(aspectItem);
                });
            } else {
                interChartAspectsContainer.innerHTML = '<p>No hay aspectos entre cartas.</p>';
            }
        }

// Función para actualizar información avanzada
function updateAdvancedInfo() {
    // Solo actualizar si calculateAnalysis está activado
    if (!calculateAnalysisToggle.checked) {
        enlacesPlanetariosContainer.innerHTML = '<p>Activa "Análisis Avanzado" para ver esta información.</p>';
        picoMayorContainer.innerHTML = '';
        picoModeradoContainer.innerHTML = '';
        picoMenorContainer.innerHTML = '';
        liberacionEnlaceContainer.innerHTML = '';
        presagiosContainer.innerHTML = '';
        relevoZodiacalContainer.innerHTML = '<p>Activa "Análisis Avanzado" para ver esta información.</p>';
        
        // Crear container de Fardarias incluso con análisis desactivado
        const relevoZodiacalSection = document.getElementById('relevoZodiacalSection');
        if (relevoZodiacalSection) {
            let fardariasContainer = document.getElementById('fardariasContainer');
            if (!fardariasContainer) {
                fardariasContainer = document.createElement('div');
                fardariasContainer.id = 'fardariasContainer';
                fardariasContainer.className = 'mt-4';
                relevoZodiacalSection.parentNode.insertBefore(fardariasContainer, relevoZodiacalSection.nextSibling);
                
                // Inicialmente dejarlo vacío, se llenará cuando se seleccione "Fardarias"
                fardariasContainer.innerHTML = '';
            }
        }
        
        // Calcular automáticamente el Relevo Zodiacal
        setTimeout(calcularYMostrarRelevoZodiacal, 100);
        return;
    }
    
    // Crear container de Fardarias si análisis está activado
    const relevoZodiacalSection = document.getElementById('relevoZodiacalSection');
    if (relevoZodiacalSection) {
        let fardariasContainer = document.getElementById('fardariasContainer');
        if (!fardariasContainer) {
            fardariasContainer = document.createElement('div');
            fardariasContainer.id = 'fardariasContainer';
            fardariasContainer.className = 'mt-4';
            relevoZodiacalSection.parentNode.insertBefore(fardariasContainer, relevoZodiacalSection.nextSibling);
            
            // Inicialmente dejarlo vacío, se llenará cuando se seleccione "Fardarias"
            fardariasContainer.innerHTML = '';
        }
    }
    
    // Calcular automáticamente el Relevo Zodiacal
    setTimeout(calcularYMostrarRelevoZodiacal, 100);

    // Enlaces planetarios
    enlacesPlanetariosContainer.innerHTML = '';
    if (enlaces && enlaces.length > 0) {
        enlaces.forEach(enlace => {
            const enlaceItem = document.createElement('div');
            
            // Determinar clase de fuerza
            let fuerzaClass = 'enlace-medio';
            if (enlace.fuerza >= 8) fuerzaClass = 'enlace-fuerte';
            else if (enlace.fuerza <= 3) fuerzaClass = 'enlace-debil';
            
            enlaceItem.className = `enlace-item ${fuerzaClass}`;
            
            enlaceItem.innerHTML = `
                <strong>${PLANET_SYMBOLS[enlace.planeta1] || enlace.planeta1}</strong> →
                <strong>${PLANET_SYMBOLS[enlace.planeta2] || enlace.planeta2}</strong>
                (Fuerza: ${enlace.fuerza})
                ${enlace.disolucion ? '<span class="badge bg-warning">Disuelto</span>' : ''}
            `;
            
            enlacesPlanetariosContainer.appendChild(enlaceItem);
        });
    } else {
        enlacesPlanetariosContainer.innerHTML = '<p>No hay enlaces planetarios significativos.</p>';
    }
    
    // Picos
    picoMayorContainer.innerHTML = '';
    if (window.pico_mayor && window.pico_mayor.length > 0) {
        window.pico_mayor.forEach(pico => {
            const picoItem = document.createElement('div');
            picoItem.className = 'pico-item';
            
            picoItem.innerHTML = `
                <strong>${PLANET_SYMBOLS[pico.planeta] || pico.planeta}</strong>
                en ${pico.signo} con fuerza ${pico.fuerza}
                ${pico.planetas_aspectados ? `<br>Aspectos favorables con: ${pico.planetas_aspectados.join(', ')}` : ''}
            `;
            
            picoMayorContainer.appendChild(picoItem);
        });
    } else {
        picoMayorContainer.innerHTML = '<p>No hay picos mayores.</p>';
    }
    
    // Repetir similar para pico moderado y menor
    picoModeradoContainer.innerHTML = '';
    if (window.pico_moderado && window.pico_moderado.length > 0) {
        // Similar a picoMayor
        window.pico_moderado.forEach(pico => {
            const picoItem = document.createElement('div');
            picoItem.className = 'pico-item';
            
            picoItem.innerHTML = `
                <strong>${PLANET_SYMBOLS[pico.planeta] || pico.planeta}</strong>
                en ${pico.signo} con fuerza ${pico.fuerza}
                ${pico.planetas_aspectados ? `<br>Aspectos favorables con: ${pico.planetas_aspectados.join(', ')}` : ''}
            `;
            
            picoModeradoContainer.appendChild(picoItem);
        });
    } else {
        picoModeradoContainer.innerHTML = '<p>No hay picos moderados.</p>';
    }
    
    picoMenorContainer.innerHTML = '';
    if (window.pico_menor && window.pico_menor.length > 0) {
        // Similar a picoMayor
        window.pico_menor.forEach(pico => {
            const picoItem = document.createElement('div');
            picoItem.className = 'pico-item';
            
            picoItem.innerHTML = `
                <strong>${PLANET_SYMBOLS[pico.planeta] || pico.planeta}</strong>
                en ${pico.signo} con fuerza ${pico.fuerza}
                ${pico.planetas_aspectados ? `<br>Aspectos favorables con: ${pico.planetas_aspectados.join(', ')}` : ''}
            `;
            
            picoMenorContainer.appendChild(picoItem);
        });
    } else {
        picoMenorContainer.innerHTML = '<p>No hay picos menores.</p>';
    }
    
    // Liberación de enlace
    liberacionEnlaceContainer.innerHTML = '';
    if (window.liberacion_enlace && window.liberacion_enlace.length > 0) {
        window.liberacion_enlace.forEach(liberacion => {
            const libItem = document.createElement('div');
            libItem.className = 'enlace-item enlace-fuerte';
            
            libItem.innerHTML = `
                <strong>${PLANET_SYMBOLS[liberacion.planeta_liberador] || liberacion.planeta_liberador}</strong>
                libera a
                <strong>${PLANET_SYMBOLS[liberacion.planeta_liberado] || liberacion.planeta_liberado}</strong>
                mediante ${liberacion.condicion}
            `;
            
            liberacionEnlaceContainer.appendChild(libItem);
        });
    } else {
        liberacionEnlaceContainer.innerHTML = '<p>No hay liberaciones de enlace.</p>';
    }
    
    // Presagios
    presagiosContainer.innerHTML = '';
    let hasPresagios = false;
    
    if (window.presagios?.buenos && window.presagios.buenos.length > 0) {
        hasPresagios = true;
        const presagiosBuenosTitle = document.createElement('h5');
        presagiosBuenosTitle.textContent = 'Presagios Favorables';
        presagiosContainer.appendChild(presagiosBuenosTitle);
        
        window.presagios.buenos.forEach(presagio => {
            const presItem = document.createElement('div');
            presItem.className = 'enlace-item enlace-fuerte';
            
            presItem.innerHTML = `
                <strong>${PLANET_SYMBOLS[presagio.planeta] || presagio.planeta}</strong>
                en ${presagio.signo}
                ${presagio.aspectos ? `con aspectos favorables` : ''}
            `;
            
            presagiosContainer.appendChild(presItem);
        });
    }
    
    if (window.presagios?.malos && window.presagios.malos.length > 0) {
        hasPresagios = true;
        const presagiosMalosTitle = document.createElement('h5');
        presagiosMalosTitle.textContent = 'Presagios Desfavorables';
        presagiosMalosTitle.className = 'mt-3';
        presagiosContainer.appendChild(presagiosMalosTitle);
        
        window.presagios.malos.forEach(presagio => {
            const presItem = document.createElement('div');
            presItem.className = 'enlace-item enlace-debil';
            
            presItem.innerHTML = `
                <strong>${PLANET_SYMBOLS[presagio.planeta] || presagio.planeta}</strong>
                en ${presagio.signo}
                ${presagio.aspectos ? `con aspectos desfavorables` : ''}
            `;
            
            presagiosContainer.appendChild(presItem);
        });
    }
    
    if (!hasPresagios) {
        presagiosContainer.innerHTML = '<p>No hay presagios significativos.</p>';
    }

    // Calcular automáticamente el Relevo Zodiacal
    calcularYMostrarRelevoZodiacal();
}

        // Función para seleccionar un planeta
        function selectPlanet(planet, isNatal) {
            // Deseleccionar aspecto si hay alguno
            selectedAspect = null;
            
            // Alternar selección
            if (selectedPlanet === planet) {
                selectedPlanet = null;
            } else {
                selectedPlanet = planet;
            }
            
            // Volver a renderizar la carta para mostrar la selección
            renderChart();
        }

        // Función para seleccionar un aspecto
        function selectAspect(aspect, type) {
            // Deseleccionar planeta si hay alguno
            selectedPlanet = null;
            
            // Alternar selección
            if (selectedAspect === aspect) {
                selectedAspect = null;
            } else {
                selectedAspect = aspect;
            }
            
            // Volver a renderizar la carta para mostrar la selección
            renderChart();
        }

        // Función para obtener signo a partir de longitud (utilidad)
        function getSignFromLongitude(longitude) {
            longitude = longitude % 360;
            
            for (const sign of SIGNS) {
                if (sign.name === "ARIES") {
                    // Caso especial para Aries que cruza el 0°
                    if (longitude >= sign.start || longitude < (sign.start + sign.length) % 360) {
                        return sign.name;
                    }
                } else if (longitude >= sign.start && longitude < sign.start + sign.length) {
                    return sign.name;
                }
            }
            
            return "ARIES"; // Por defecto
        }

        // Implementación de Relevo Zodiacal
        // Función para generar la secuencia de signos a partir del ascendente
        function generarSecuencia(inicio) {
            // Normalizar el ascendente
            var ascNormalizado = SIGNOS_NORMALIZADOS[inicio.toLowerCase()] || inicio.toUpperCase();
            
            // Lista base de signos en orden
            var signos = Object.keys(DURACION_POR_NIVEL);
            
            // Mapeo de nombres de signos para compatibilidad
            const signMap = {
                'ARIES': 'aries',
                'TAURUS': 'tauro',
                'GEMINI': 'geminis',
                'CANCER': 'cancer',
                'LEO': 'leo',
                'VIRGO': 'virgo',
                'LIBRA': 'libra',
                'SCORPIO': 'escorpio',
                'OPHIUCHUS': 'ofiuco',
                'SAGITTARIUS': 'sagitario',
                'CAPRICORN': 'capricornio',
                'AQUARIUS': 'acuario',
                'PISCES': 'piscis'
            };
            
            // Intentar buscar el signo en cualquier formato
            let pos = -1;
            if (signMap[ascNormalizado]) {
                pos = signos.indexOf(signMap[ascNormalizado]);
            } else {
                pos = signos.indexOf(ascNormalizado.toLowerCase());
            }
            
            if (pos === -1) {
                // Si no se encuentra el ascendente, usar ARIES como predeterminado
                console.log("Ascendente no encontrado en la lista de signos, usando ARIES");
                pos = signos.indexOf('aries');
            }
            
            // Generar la secuencia rotando la lista desde el ascendente
            return signos.slice(pos).concat(signos.slice(0, pos));
        }

// Función mejorada para calcular y mostrar el Relevo Zodiacal
function calcularYMostrarRelevoZodiacal() {
    console.log("Calculando y mostrando Relevo Zodiacal automáticamente");
    
    // Verificar que existe el contenedor
    if (!relevoZodiacalContainer) {
        console.error("No se encontró el contenedor de Relevo Zodiacal");
        return;
    }
    
    // Mostrar mensaje de carga
    relevoZodiacalContainer.innerHTML = '<div class="alert alert-info">Calculando relevo zodiacal...</div>';
    
    // Verificar si tenemos los datos necesarios (natal planets y ascendente)
    if (!natalPlanets || natalPlanets.length === 0) {
        relevoZodiacalContainer.innerHTML = '<div class="alert alert-warning">No se encontraron datos de la carta natal. Por favor, calcula la carta astral primero.</div>';
        return;
    }
    
    // Obtener fecha de nacimiento y tránsito
    const transitDate = transitDateInput ? transitDateInput.value : null;
    
    if (!transitDate) {
        relevoZodiacalContainer.innerHTML = '<div class="alert alert-warning">No se pudo encontrar la fecha de tránsito. Por favor, asegúrate de haberla seleccionado.</div>';
        return;
    }
    
    if (!birthDate) {
        relevoZodiacalContainer.innerHTML = '<div class="alert alert-warning">No se pudo determinar la fecha de nacimiento.</div>';
        return;
    }
    
    // Obtener ascendente
    const ascPlanet = natalPlanets.find(p => p.name === 'ASC');
    if (!ascPlanet || !ascPlanet.sign) {
        relevoZodiacalContainer.innerHTML = '<div class="alert alert-warning">No se pudo determinar el ascendente.</div>';
        return;
    }
    
    console.log("Calculando Relevo para:", ascPlanet.sign);
    
    // Usar la nueva función que muestra solo periodos activos
    calcularYMostrarSoloRelevsActivos(birthDate, ascPlanet.sign, transitDate);
}

// Función modificada para mostrar solo un periodo activo por nivel
function mostrarPeriodosRelevo(periodos) {
    // Verificar si hay periodos
    if (!periodos || periodos.length === 0) {
        relevoZodiacalContainer.innerHTML = '<div class="alert alert-info">No se encontraron periodos activos para la fecha seleccionada.</div>';
        return;
    }
    
    const fechaTransito = transitDateInput ? new Date(transitDateInput.value) : new Date();
    console.log("Mostrando relevo para fecha:", fechaTransito.toDateString());
    
    // Buscar el periodo activo de nivel 1
    let periodoActivo = null;
    for (const periodo of periodos) {
        try {
            if (periodo.activo) {
                periodoActivo = periodo;
                break;
            }
            
            // Intentar convertir fechas manualmente
            const fechaInicio = convertirFechaDesdeString(periodo.fechaInicio);
            const fechaFin = convertirFechaDesdeString(periodo.fechaFin);
            
            if (fechaTransito >= fechaInicio && fechaTransito <= fechaFin) {
                periodoActivo = periodo;
                periodoActivo.activo = true;
                break;
            }
        } catch (e) {
            console.error("Error al procesar periodo:", e);
        }
    }
    
    // Si no encontramos periodo activo, usar el primero
    if (!periodoActivo && periodos.length > 0) {
        periodoActivo = periodos[0];
        periodoActivo.activo = true;
    }
    
    if (!periodoActivo) {
        relevoZodiacalContainer.innerHTML = '<div class="alert alert-warning">No se pudo determinar el periodo activo.</div>';
        return;
    }
    
    // Generar HTML para el periodo activo
    let html = '';
    const elementoInfo = ELEMENTOS_SIGNOS[SIGNOS_NORMALIZADOS[periodoActivo.signo]] || {
        elemento: 'Neutral',
        color: '#f8f9fa',
        borde: '#6c757d'
    };
    
    html += `
        <div class="relevo-periodo ${periodoActivo.elemento.toLowerCase()} periodo-activo">
            <h5>
                ${periodoActivo.signo.charAt(0).toUpperCase() + periodoActivo.signo.slice(1)} - Nivel 1
                <small class="text-muted">(Elemento: ${periodoActivo.elemento}, Regente: ${periodoActivo.regente})</small>
                <span class="badge bg-success">Período Actual</span>
            </h5>
            <p>
                Periodo: ${periodoActivo.fechaInicio} - ${periodoActivo.fechaFin}
                <br>
                Edad: ${periodoActivo.edad} años
            </p>
    `;
    
    // Buscar subperiodo activo de nivel 2
    let subperiodoActivo = null;
    
    if (periodoActivo.subperiodos && periodoActivo.subperiodos.length > 0) {
        for (const subp of periodoActivo.subperiodos) {
            try {
                if (subp.activo) {
                    subperiodoActivo = subp;
                    break;
                }
                
                // Intentar convertir fechas manualmente
                const fechaInicio = convertirFechaDesdeString(subp.fechaInicio);
                const fechaFin = convertirFechaDesdeString(subp.fechaFin);
                
                if (fechaTransito >= fechaInicio && fechaTransito <= fechaFin) {
                    subperiodoActivo = subp;
                    subperiodoActivo.activo = true;
                    break;
                }
            } catch (e) {
                console.error("Error al procesar subperiodo:", e);
            }
        }
        
        // Si no encontramos subperiodo activo, usar el primero
        if (!subperiodoActivo && periodoActivo.subperiodos.length > 0) {
            subperiodoActivo = periodoActivo.subperiodos[0];
            subperiodoActivo.activo = true;
        }
    }
    
    // Mostrar subperiodo activo si existe
    if (subperiodoActivo) {
        html += `
            <div class="relevo-subperiodo ${subperiodoActivo.elemento.toLowerCase()} periodo-activo">
                <h6>
                    ${subperiodoActivo.signo.charAt(0).toUpperCase() + subperiodoActivo.signo.slice(1)} - Nivel 2
                    <small class="text-muted">(Elemento: ${subperiodoActivo.elemento}, Regente: ${subperiodoActivo.regente})</small>
                    <span class="badge bg-success">Período Actual</span>
                </h6>
                <p>
                    Subperiodo: ${subperiodoActivo.fechaInicio} - ${subperiodoActivo.fechaFin}
                    <br>
                    Edad: ${subperiodoActivo.edad} años
                </p>
        `;
        
        // Buscar sub-subperiodo activo de nivel 3
        let subsubperiodoActivo = null;
        
        if (subperiodoActivo.subperiodos && subperiodoActivo.subperiodos.length > 0) {
            for (const subsubp of subperiodoActivo.subperiodos) {
                try {
                    if (subsubp.activo) {
                        subsubperiodoActivo = subsubp;
                        break;
                    }
                    
                    // Intentar convertir fechas manualmente
                    const fechaInicio = convertirFechaDesdeString(subsubp.fechaInicio);
                    const fechaFin = convertirFechaDesdeString(subsubp.fechaFin);
                    
                    if (fechaTransito >= fechaInicio && fechaTransito <= fechaFin) {
                        subsubperiodoActivo = subsubp;
                        subsubperiodoActivo.activo = true;
                        break;
                    }
                } catch (e) {
                    console.error("Error al procesar sub-subperiodo:", e);
                }
            }
            
            // Si no encontramos sub-subperiodo activo, usar el primero
            if (!subsubperiodoActivo && subperiodoActivo.subperiodos.length > 0) {
                subsubperiodoActivo = subperiodoActivo.subperiodos[0];
                subsubperiodoActivo.activo = true;
            }
        }
        
        // Mostrar sub-subperiodo activo si existe
        if (subsubperiodoActivo) {
            html += `
                <div class="relevo-subsubperiodo ${subsubperiodoActivo.elemento.toLowerCase()} periodo-activo">
                    <h6>
                        ${subsubperiodoActivo.signo.charAt(0).toUpperCase() + subsubperiodoActivo.signo.slice(1)} - Nivel 3
                        <small class="text-muted">(Elemento: ${subsubperiodoActivo.elemento}, Regente: ${subsubperiodoActivo.regente})</small>
                        <span class="badge bg-success">Período Actual</span>
                    </h6>
                    <p>
                        Sub-subperiodo: ${subsubperiodoActivo.fechaInicio} - ${subsubperiodoActivo.fechaFin}
                        <br>
                        Edad: ${subsubperiodoActivo.edad} años
                    </p>
            `;
            
            // Buscar sub-sub-subperiodo activo (nivel 4 - días)
            let diaActivo = null;
            
            if (subsubperiodoActivo.subperiodos && subsubperiodoActivo.subperiodos.length > 0) {
                for (const dia of subsubperiodoActivo.subperiodos) {
                    try {
                        if (dia.activo) {
                            diaActivo = dia;
                            break;
                        }
                        
                        // Intentar convertir fechas manualmente
                        const fechaInicio = convertirFechaDesdeString(dia.fechaInicio);
                        const fechaFin = convertirFechaDesdeString(dia.fechaFin);
                        
                        if (fechaTransito >= fechaInicio && fechaTransito <= fechaFin) {
                            diaActivo = dia;
                            diaActivo.activo = true;
                            break;
                        }
                    } catch (e) {
                        console.error("Error al procesar día:", e);
                    }
                }
                
                // Si no encontramos día activo, usar el primero
                if (!diaActivo && subsubperiodoActivo.subperiodos.length > 0) {
                    diaActivo = subsubperiodoActivo.subperiodos[0];
                    diaActivo.activo = true;
                }
            }
            
            // Mostrar día activo si existe
            if (diaActivo) {
                html += `
                    <div class="relevo-subsubsubperiodo ${diaActivo.elemento.toLowerCase()} periodo-activo" style="margin-left: 60px; margin-bottom: 5px; border-left: 4px solid ${elementoInfo.borde};">
                        <h6>
                            ${diaActivo.signo.charAt(0).toUpperCase() + diaActivo.signo.slice(1)} - Nivel 4
                            <small class="text-muted">(Elemento: ${diaActivo.elemento}, Regente: ${diaActivo.regente})</small>
                            <span class="badge bg-success">Día Actual</span>
                        </h6>
                        <p>
                            Día: ${diaActivo.fechaInicio}
                            <br>
                            Edad: ${diaActivo.edad} años
                        </p>
                    </div>
                `;
            }
            
            html += `</div>`;
        }
        
        html += `</div>`;
    }
    
    html += `</div>`;
    
    relevoZodiacalContainer.innerHTML = html;
    console.log("Relevo Zodiacal mostrado correctamente (solo periodos activos)");
}

// Función auxiliar para convertir fechas en formato dd/mm/yyyy a objetos Date
function convertirFechaDesdeString(fechaStr) {
    try {
        // Intentar parsear fecha en formato dd/mm/yyyy
        const partes = fechaStr.split('/');
        if (partes.length === 3) {
            return new Date(
                parseInt(partes[2]),  // año
                parseInt(partes[1]) - 1,  // mes (0-11)
                parseInt(partes[0])   // día
            );
        }
        
        // Intentar parsear como fecha ISO
        return new Date(fechaStr);
    } catch (e) {
        console.error("Error al convertir fecha:", fechaStr, e);
        return new Date(); // Fecha actual como fallback
    }
}

// Versión robusta para calcular el relevo zodiacal - mostrando solo un periodo por nivel
function calcularRelevoZodiacalRobusto(birthDate, ascendente, transitDate) {
    // Convertir fechas a objetos Date
    const fechaNac = new Date(birthDate);
    const fechaTransito = new Date(transitDate);
    
    // Normalizar el ascendente para compatibilidad
    const ascNormalizado = ascendente.toUpperCase();
    
    // Mapeo normalizado para signos
    const signoNormalizado = {
        'ARIES': 'aries',
        'TAURUS': 'tauro',
        'GEMINI': 'geminis',
        'CANCER': 'cancer',
        'LEO': 'leo',
        'VIRGO': 'virgo',
        'LIBRA': 'libra',
        'SCORPIO': 'escorpio',
        'OPHIUCHUS': 'ofiuco',
        'SAGITTARIUS': 'sagitario',
        'CAPRICORN': 'capricornio',
        'AQUARIUS': 'acuario',
        'PISCES': 'piscis'
    };
    
    // Convertir el ascendente a formato esperado
    let ascFormato = signoNormalizado[ascNormalizado] || ascendente.toLowerCase();
    
    // Generar secuencia de signos a partir del ascendente
    const secuencia = generarSecuencia(ascFormato);
    console.log("Secuencia de signos generada:", secuencia);
    
    // Mapeo de elementos para signos
    const elementosSignos = {
        'aries': 'Fuego',
        'leo': 'Fuego',
        'sagitario': 'Fuego',
        'tauro': 'Tierra',
        'virgo': 'Tierra',
        'capricornio': 'Tierra',
        'geminis': 'Aire',
        'libra': 'Aire',
        'acuario': 'Aire',
        'ofiuco': 'Aire',
        'cancer': 'Agua',
        'escorpio': 'Agua',
        'piscis': 'Agua'
    };
    
    // Regentes planetarios para cada signo
    const regentesSignos = {
        'aries': 'Marte',
        'tauro': 'Venus',
        'geminis': 'Mercurio',
        'cancer': 'Luna',
        'leo': 'Sol',
        'virgo': 'Mercurio',
        'libra': 'Venus',
        'escorpio': 'Marte',
        'ofiuco': 'Saturno',
        'sagitario': 'Júpiter',
        'capricornio': 'Sol',
        'acuario': 'Luna',
        'piscis': 'Júpiter'
    };
    
    // Periodos activos para la fecha de tránsito
    const periodosActivos = [];
    let diaActual = 0;
    
    // NIVEL 1 - Encontrar el periodo principal activo
    let periodoNivel1 = null;
    for (let i = 0; i < secuencia.length; i++) {
        const signo = secuencia[i];
        
        // Verificar que el signo existe en DURACION_POR_NIVEL
        if (!DURACION_POR_NIVEL[signo]) {
            console.warn(`Signo "${signo}" no encontrado en DURACION_POR_NIVEL, saltando...`);
            continue;
        }
        
        const anios = DURACION_POR_NIVEL[signo];
        const diasEnPeriodo = anios * DURACIONES.AÑO;
        
        // Calcular fecha de inicio y fin del periodo
        const fechaInicio = new Date(fechaNac);
        fechaInicio.setDate(fechaInicio.getDate() + diaActual);
        
        const fechaFin = new Date(fechaInicio);
        fechaFin.setDate(fechaInicio.getDate() + diasEnPeriodo);
        
        // Comprobar si la fecha de tránsito está dentro de este periodo
        if (fechaTransito >= fechaInicio && fechaTransito <= fechaFin) {
            // Calcular edad para este periodo
            const edad = calcularEdad(fechaNac, fechaInicio);
            
            // Crear objeto de periodo principal
            periodoNivel1 = {
                signo: signo,
                nivel: 1,
                fechaInicio: fechaInicio.toLocaleDateString('es-ES'),
                fechaFin: fechaFin.toLocaleDateString('es-ES'),
                edad: edad,
                regente: regentesSignos[signo] || 'Desconocido',
                elemento: elementosSignos[signo] || 'Neutral',
                activo: true,
                subperiodos: []
            };
            
            break; // Salir del bucle después de encontrar el periodo activo
        }
        
        // Avanzar al siguiente periodo principal
        diaActual += diasEnPeriodo;
    }
    
    // Si no encontramos un periodo activo, devolver array vacío
    if (!periodoNivel1) {
        return periodosActivos;
    }
    
    // NIVEL 2 - Encontrar el subperiodo activo
    const signoNivel1 = periodoNivel1.signo;
    const subSecuencia = generarSecuencia(signoNivel1);
    let diaInicioNivel1 = 0;
    let fechaInicioNivel1 = new Date(fechaNac);
    
    // Calcular el día de inicio del periodo nivel 1
    for (let i = 0; i < secuencia.length; i++) {
        const signo = secuencia[i];
        if (signo === signoNivel1) {
            break;
        }
        const anios = DURACION_POR_NIVEL[signo] || 0;
        diaInicioNivel1 += anios * DURACIONES.AÑO;
    }
    fechaInicioNivel1.setDate(fechaInicioNivel1.getDate() + diaInicioNivel1);
    
    // Buscar subperiodo activo
    let periodoNivel2 = null;
    let diaActualNivel2 = diaInicioNivel1;
    
    for (let j = 0; j < subSecuencia.length; j++) {
        const subSigno = subSecuencia[j];
        
        // Verificar que el subSigno existe en DURACION_POR_NIVEL
        if (!DURACION_POR_NIVEL[subSigno]) {
            console.warn(`SubSigno "${subSigno}" no encontrado en DURACION_POR_NIVEL, saltando...`);
            continue;
        }
        
        const meses = DURACION_POR_NIVEL[subSigno];
        const diasEnSubperiodo = meses * DURACIONES.MES;
        
        // Calcular fecha de inicio y fin del subperiodo
        const fechaInicioSub = new Date(fechaNac);
        fechaInicioSub.setDate(fechaInicioSub.getDate() + diaActualNivel2);
        
        const fechaFinSub = new Date(fechaInicioSub);
        fechaFinSub.setDate(fechaInicioSub.getDate() + diasEnSubperiodo);
        
        // Verificar límites con periodo principal
        const fechaFinPeriodo1 = new Date(fechaNac);
        fechaFinPeriodo1.setDate(fechaFinPeriodo1.getDate() + diaInicioNivel1 + (DURACION_POR_NIVEL[signoNivel1] * DURACIONES.AÑO));
        
        if (fechaFinSub > fechaFinPeriodo1) {
            fechaFinSub.setTime(fechaFinPeriodo1.getTime());
        }
        
        // Comprobar si la fecha de tránsito está dentro de este subperiodo
        if (fechaTransito >= fechaInicioSub && fechaTransito <= fechaFinSub) {
            // Calcular edad para este subperiodo
            const edadSub = calcularEdad(fechaNac, fechaInicioSub);
            
            // Crear objeto de subperiodo
            periodoNivel2 = {
                signo: subSigno,
                nivel: 2,
                fechaInicio: fechaInicioSub.toLocaleDateString('es-ES'),
                fechaFin: fechaFinSub.toLocaleDateString('es-ES'),
                edad: edadSub,
                regente: regentesSignos[subSigno] || 'Desconocido',
                elemento: elementosSignos[subSigno] || 'Neutral',
                activo: true,
                subperiodos: []
            };
            
            break; // Salir del bucle después de encontrar el subperiodo activo
        }
        
        // Avanzar al siguiente subperiodo
        diaActualNivel2 += diasEnSubperiodo;
    }
    
    // Si no encontramos un subperiodo activo, usar datos aproximados
    if (!periodoNivel2) {
        periodoNivel2 = {
            signo: signoNivel1, // Usar el mismo signo del nivel 1 como respaldo
            nivel: 2,
            fechaInicio: "No determinado",
            fechaFin: "No determinado",
            edad: periodoNivel1.edad,
            regente: regentesSignos[signoNivel1] || 'Desconocido',
            elemento: elementosSignos[signoNivel1] || 'Neutral',
            activo: true,
            subperiodos: []
        };
    }
    
    // NIVEL 3 - Encontrar el sub-subperiodo activo
    const signoNivel2 = periodoNivel2.signo;
    const subSubSecuencia = generarSecuencia(signoNivel2);
    let diaInicioNivel2 = 0;
    
    // Buscar sub-subperiodo activo
    let periodoNivel3 = null;
    // Calcular el día de inicio del periodo nivel 2 (es complejo, así que usamos las fechas)
    const fechaInicioNivel2 = new Date(periodoNivel2.fechaInicio.split('/').reverse().join('/'));
    let diaActualNivel3 = Math.floor((fechaInicioNivel2.getTime() - fechaNac.getTime()) / (24 * 60 * 60 * 1000));
    
    for (let k = 0; k < subSubSecuencia.length; k++) {
        const subSubSigno = subSubSecuencia[k];
        
        // Verificar que el subSubSigno existe en DURACION_POR_NIVEL
        if (!DURACION_POR_NIVEL[subSubSigno]) {
            console.warn(`SubSubSigno "${subSubSigno}" no encontrado en DURACION_POR_NIVEL, saltando...`);
            continue;
        }
        
        const semanas = DURACION_POR_NIVEL[subSubSigno];
        const diasEnSubSubperiodo = semanas * DURACIONES.SEMANA;
        
        // Calcular fecha de inicio y fin del sub-subperiodo
        const fechaInicioSubSub = new Date(fechaNac);
        fechaInicioSubSub.setDate(fechaInicioSubSub.getDate() + diaActualNivel3);
        
        const fechaFinSubSub = new Date(fechaInicioSubSub);
        fechaFinSubSub.setDate(fechaInicioSubSub.getDate() + diasEnSubSubperiodo);
        
        // Verificar límites con periodo nivel 2
        const fechaFinNivel2 = new Date(periodoNivel2.fechaFin.split('/').reverse().join('/'));
        if (fechaFinSubSub > fechaFinNivel2) {
            fechaFinSubSub.setTime(fechaFinNivel2.getTime());
        }
        
        // Comprobar si la fecha de tránsito está dentro de este sub-subperiodo
        if (fechaTransito >= fechaInicioSubSub && fechaTransito <= fechaFinSubSub) {
            // Calcular edad para este sub-subperiodo
            const edadSubSub = calcularEdad(fechaNac, fechaInicioSubSub);
            
            // Crear objeto de sub-subperiodo
            periodoNivel3 = {
                signo: subSubSigno,
                nivel: 3,
                fechaInicio: fechaInicioSubSub.toLocaleDateString('es-ES'),
                fechaFin: fechaFinSubSub.toLocaleDateString('es-ES'),
                edad: edadSubSub,
                regente: regentesSignos[subSubSigno] || 'Desconocido',
                elemento: elementosSignos[subSubSigno] || 'Neutral',
                activo: true,
                subperiodos: []
            };
            
            break; // Salir del bucle después de encontrar el sub-subperiodo activo
        }
        
        // Avanzar al siguiente sub-subperiodo
        diaActualNivel3 += diasEnSubSubperiodo;
    }
    
    // Si no encontramos un sub-subperiodo activo, usar datos aproximados
    if (!periodoNivel3) {
        periodoNivel3 = {
            signo: signoNivel2, // Usar el mismo signo del nivel 2 como respaldo
            nivel: 3,
            fechaInicio: "No determinado",
            fechaFin: "No determinado",
            edad: periodoNivel2.edad,
            regente: regentesSignos[signoNivel2] || 'Desconocido',
            elemento: elementosSignos[signoNivel2] || 'Neutral',
            activo: true,
            subperiodos: []
        };
    }
    
    // NIVEL 4 - Encontrar el sub-sub-subperiodo activo (día específico)
    const signoNivel3 = periodoNivel3.signo;
    const subSubSubSecuencia = generarSecuencia(signoNivel3);
    
    // Buscar sub-sub-subperiodo activo
    let periodoNivel4 = null;
    // Determinar el día actual - en nivel 4 nos interesa específicamente el día exacto
    
    // Buscar qué signo zodiacal corresponde específicamente a la fecha de tránsito
    // Al ser nivel 4, cada signo corresponde a días específicos
    let signoDelDia = null;
    let fechaInicioNivel3 = new Date(periodoNivel3.fechaInicio.split('/').reverse().join('/'));
    let diaActualNivel4 = Math.floor((fechaInicioNivel3.getTime() - fechaNac.getTime()) / (24 * 60 * 60 * 1000));
    
    for (let l = 0; l < subSubSubSecuencia.length; l++) {
        const subSubSubSigno = subSubSubSecuencia[l];
        
        // Verificar que el subSubSubSigno existe en DURACION_POR_NIVEL
        if (!DURACION_POR_NIVEL[subSubSubSigno]) {
            console.warn(`SubSubSubSigno "${subSubSubSigno}" no encontrado en DURACION_POR_NIVEL, saltando...`);
            continue;
        }
        
        const dias = DURACION_POR_NIVEL[subSubSubSigno];
        const diasEnSubSubSubperiodo = dias * DURACIONES.DIA;
        
        // Calcular fecha de inicio y fin para el nivel 4
        const fechaInicioSubSubSub = new Date(fechaNac);
        fechaInicioSubSubSub.setDate(fechaInicioSubSubSub.getDate() + diaActualNivel4);
        
        const fechaFinSubSubSub = new Date(fechaInicioSubSubSub);
        fechaFinSubSubSub.setDate(fechaInicioSubSubSub.getDate() + diasEnSubSubSubperiodo);
        
        // Verificar límites con periodo nivel 3
        const fechaFinNivel3 = new Date(periodoNivel3.fechaFin.split('/').reverse().join('/'));
        if (fechaFinSubSubSub > fechaFinNivel3) {
            fechaFinSubSubSub.setTime(fechaFinNivel3.getTime());
        }
        
        // Comprobar si la fecha de tránsito está dentro de este sub-sub-subperiodo
        if (fechaTransito >= fechaInicioSubSubSub && fechaTransito <= fechaFinSubSubSub) {
            // Encontramos el signo del día específico
            signoDelDia = subSubSubSigno;
            
            // Calcular edad para este nivel
            const edadSubSubSub = calcularEdad(fechaNac, fechaInicioSubSubSub);
            
            // Crear objeto de nivel 4 específico para este día
            periodoNivel4 = {
                signo: subSubSubSigno,
                nivel: 4,
                fechaInicio: fechaInicioSubSubSub.toLocaleDateString('es-ES'),
                fechaFin: fechaFinSubSubSub.toLocaleDateString('es-ES'),
                edad: edadSubSubSub,
                regente: regentesSignos[subSubSubSigno] || 'Desconocido',
                elemento: elementosSignos[subSubSubSigno] || 'Neutral',
                activo: true
            };
            
            break; // Salir del bucle después de encontrar el día específico
        }
        
        // Avanzar al siguiente día
        diaActualNivel4 += diasEnSubSubSubperiodo;
    }
    
    // Si no encontramos un periodo de nivel 4 activo, crear uno para el día exacto
    if (!periodoNivel4) {
        // Usar el primer signo de la secuencia como respaldo
        const signoRespaldo = subSubSubSecuencia[0];
        
        periodoNivel4 = {
            signo: signoRespaldo,
            nivel: 4,
            fechaInicio: fechaTransito.toLocaleDateString('es-ES'),
            fechaFin: new Date(fechaTransito.getTime() + 24*60*60*1000).toLocaleDateString('es-ES'),
            edad: calcularEdad(fechaNac, fechaTransito),
            regente: regentesSignos[signoRespaldo] || 'Desconocido',
            elemento: elementosSignos[signoRespaldo] || 'Neutral',
            activo: true
        };
    }
    
    // Construir la estructura final de periodos anidados
    periodoNivel3.subperiodos = [periodoNivel4]; // Solo el periodo de nivel 4 activo
    periodoNivel2.subperiodos = [periodoNivel3]; // Solo el periodo de nivel 3 activo
    periodoNivel1.subperiodos = [periodoNivel2]; // Solo el periodo de nivel 2 activo
    periodosActivos.push(periodoNivel1); // Solo el periodo de nivel 1 activo
    
    return periodosActivos;
}

<!-- 4. Modificar la función showTransitForDate para incluir el parámetro de zodiaco sideral -->
function showTransitForDate(fecha) {
    // Asegurarse de que tenemos una ciudad para los tránsitos
    if (!transitCityInput.value) {
        transitCityInput.value = cityInput.value; // Usar la misma ciudad que la carta natal
    }
    
    // Actualizar campos de fecha y hora de tránsito
    transitDateInput.value = fecha;
    transitTimeInput.value = '12:00'; // Usar mediodía por defecto
    
    // Activar el toggle de tránsitos si no está activo
    if (!showTransitsToggle.checked) {
        showTransitsToggle.checked = true;
        toggleTransits();
    }
    
    // Asegurarse que el análisis avanzado está activado
    if (!calculateAnalysisToggle.checked) {
        calculateAnalysisToggle.checked = true;
    }
    
    // Calcular tránsitos para esta fecha
    const transitCoords = getSelectedCityCoordinates(transitCityInput, transitCityList);
    
    // Obtener el estado del toggle del zodiaco sideral
    const useSiderealZodiac = document.getElementById('useSiderealZodiac').checked;
    
    // Mostrar loading
    loadingIndicator.style.display = 'flex';
    
    fetch('/calculate', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({
            city: transitCityInput.value,
            date: fecha,
            time: transitTimeInput.value,
            lat: transitCoords.lat,
            lon: transitCoords.lon,
            calculateAnalysis: true, // Siempre calcular análisis avanzado para los tránsitos
            useSidereal: useSiderealZodiac  // Agregar parámetro de zodiaco sideral
        })
    })
    .then(response => response.json())
    .then(data => {
        console.log("Datos de tránsito para fecha específica:", data);
        
        if (data.error) {
            throw new Error(data.error);
        }
        
        // Actualizar tránsitos
        transitPlanets = data.positions;
        
        // Calcular aspectos entre cartas
        interChartAspects = calculateAspects(natalPlanets, transitPlanets);
        
        // Renderizar carta
        renderChart();
        
        // Hacer scroll hacia la carta
        chartContent.scrollIntoView({ behavior: 'smooth' });
    })
    .catch(error => {
        console.error('Error calculando tránsitos para fecha específica:', error);
        showError(`Error calculando tránsitos: ${error.message}`);
        loadingIndicator.style.display = 'none';
    });
}

// Función modificada para calcular y mostrar solo los períodos activos
function calcularYMostrarSoloRelevsActivos(fechaNac, ascendente, fechaTransito) {
    console.log("Calculando relevo con solo periodos activos para fecha:", fechaTransito);
    
    try {
        // Convertir fechas a objetos Date
        let fechaNacObj = new Date(fechaNac);
        let fechaTransitoObj = new Date(fechaTransito);
        
        // Validar fechas
        if (isNaN(fechaNacObj.getTime()) || isNaN(fechaTransitoObj.getTime())) {
            console.error("Fechas inválidas:", fechaNac, fechaTransito);
            relevoZodiacalContainer.innerHTML = '<div class="alert alert-danger">Fechas inválidas. Por favor, selecciona fechas válidas.</div>';
            return;
        }
        
        // Determinar qué punto usar como referencia para el relevo
        let puntoReferencia = ascendente; // Por defecto usar el ascendente
        
        // Si hay un punto de referencia seleccionado, usarlo en lugar del ascendente
        if (puntoReferenciaSeleccionado) {
            if (puntoReferenciaSeleccionado === "PARTE_FORTUNA" || puntoReferenciaSeleccionado === "PARTE_ESPIRITU") {
                // Buscar el signo del punto seleccionado en la carta natal
                const puntoPF = natalPlanets.find(p => p.name === "PARTE_FORTUNA");
                const puntoPE = natalPlanets.find(p => p.name === "PARTE_ESPIRITU");
                
                if (puntoReferenciaSeleccionado === "PARTE_FORTUNA" && puntoPF) {
                    puntoReferencia = puntoPF.sign;
                    console.log("Usando PARTE_FORTUNA como referencia. Signo:", puntoReferencia);
                } 
                else if (puntoReferenciaSeleccionado === "PARTE_ESPIRITU" && puntoPE) {
                    puntoReferencia = puntoPE.sign;
                    console.log("Usando PARTE_ESPIRITU como referencia. Signo:", puntoReferencia);
                }
                else {
                    console.log("Punto seleccionado no encontrado, usando Ascendente como respaldo");
                }
            }
        }
        
        // Normalizar el punto de referencia
        puntoReferencia = normalizarSigno(puntoReferencia);
        console.log("Punto de referencia normalizado:", puntoReferencia);
        
        // Obtener la secuencia zodiacal desde el punto de referencia
        const secuencia = generarSecuencia(puntoReferencia);
        console.log("Secuencia de signos:", secuencia);
        
        // Buscar el período activo para la fecha de tránsito
        // Convertir a milisegundos para obtener la diferencia exacta
        const difDias = Math.floor((fechaTransitoObj - fechaNacObj) / (24 * 60 * 60 * 1000));
        console.log("Días transcurridos desde nacimiento:", difDias);
        
        // Encontrar el período activo
        let diaActual = 0;
        let periodoActivo = null;
        let indiceSignoActivo = 0;
        let cicloActual = 0;
        
        // Repetir hasta encontrar el período que contiene la fecha de tránsito
        while (diaActual <= difDias) {
            for (let i = 0; i < secuencia.length; i++) {
                const signo = secuencia[i];
                const duracionPeriodo = DURACION_POR_NIVEL[signo] * DURACIONES.AÑO;
                
                // Verificar si la fecha de tránsito está en este período
                if (diaActual <= difDias && difDias < diaActual + duracionPeriodo) {
                    // Encontramos el período activo
                    periodoActivo = signo;
                    indiceSignoActivo = i;
                    break;
                }
                
                diaActual += duracionPeriodo;
            }
            
            // Si encontramos el período activo, salir del bucle
            if (periodoActivo) break;
            
            // Si llegamos al final de un ciclo, comenzar uno nuevo
            cicloActual++;
        }
        
        if (!periodoActivo) {
            relevoZodiacalContainer.innerHTML = '<div class="alert alert-warning">No se pudo encontrar el período activo para la fecha de tránsito.</div>';
            return;
        }
        
        console.log("Período activo:", periodoActivo, "Ciclo:", cicloActual, "Índice:", indiceSignoActivo);
        
        // Calcular fechas del período activo
        const fechaInicioPeriodo = new Date(fechaNacObj.getTime() + diaActual * 24 * 60 * 60 * 1000);
        const duracionPeriodoActivo = DURACION_POR_NIVEL[periodoActivo] * DURACIONES.AÑO;
        const fechaFinPeriodo = new Date(fechaInicioPeriodo.getTime() + duracionPeriodoActivo * 24 * 60 * 60 * 1000);
        
        // Construir el objeto del período activo
        const periodoObj = {
            signo: periodoActivo,
            nivel: 1,
            fechaInicio: fechaInicioPeriodo.toLocaleDateString('es-ES'),
            fechaFin: fechaFinPeriodo.toLocaleDateString('es-ES'),
            edad: calcularEdad(fechaNacObj, fechaInicioPeriodo),
            elemento: getElementoSigno(periodoActivo),
            regente: getRegenteSigno(periodoActivo),
            activo: true,
            subperiodos: []
        };
        
        // Calcular subperíodos activos recursivamente
        const difDiasEnPeriodo = difDias - diaActual;
        periodoObj.subperiodos = calcularSubperiodos(
            fechaNacObj,
            secuencia,
            indiceSignoActivo,
            fechaInicioPeriodo,
            duracionPeriodoActivo, 
            difDiasEnPeriodo,
            2,  // Nivel 2 (Meses)
            periodoObj.regente, // Planeta del período principal
            fechaTransitoObj
        );
        
        // Mostrar los períodos activos
        mostrarPeriodosRelevo([periodoObj]);
        
    } catch (error) {
        console.error("Error en calcularYMostrarSoloRelevsActivos:", error);
        relevoZodiacalContainer.innerHTML = `<div class="alert alert-danger">Error al calcular el relevo zodiacal: ${error.message}</div>`;
    }
}

// Funciones auxiliares
function normalizarSigno(signo) {
    // Normalizar nombre del signo
    signo = signo.toLowerCase();
    
    const normalizacion = {
        'aries': 'aries',
        'tauro': 'tauro',
        'taurus': 'tauro',
        'gemini': 'geminis',
        'geminis': 'geminis',
        'géminis': 'geminis',
        'cancer': 'cancer',
        'cáncer': 'cancer',
        'leo': 'leo',
        'virgo': 'virgo',
        'libra': 'libra',
        'scorpio': 'escorpio',
        'escorpio': 'escorpio',
        'ophiuchus': 'ofiuco',
        'ofiuco': 'ofiuco',
        'sagittarius': 'sagitario',
        'sagitario': 'sagitario',
        'capricorn': 'capricornio',
        'capricornio': 'capricornio',
        'aquarius': 'acuario',
        'acuario': 'acuario',
        'pisces': 'piscis',
        'piscis': 'piscis'
    };
    
    return normalizacion[signo] || 'aries';
}

// Función auxiliar para obtener el elemento de un signo
function getElementoSigno(signo) {
    // Mapa de elementos para los signos
    const elementos = {
        'aries': 'Fuego',
        'leo': 'Fuego',
        'sagitario': 'Fuego',
        'tauro': 'Tierra',
        'virgo': 'Tierra',
        'capricornio': 'Tierra',
        'geminis': 'Aire',
        'libra': 'Aire',
        'acuario': 'Aire',
        'ofiuco': 'Aire',
        'cancer': 'Agua',
        'escorpio': 'Agua',
        'piscis': 'Agua'
    };
    
    return elementos[signo] || 'Neutral';
}

// Función auxiliar para obtener el regente de un signo
function getRegenteSigno(signo) {
    // Mapa de regentes para los signos
    const regentes = {
        'aries': 'MARTE',
        'tauro': 'VENUS',
        'geminis': 'MERCURIO',
        'cancer': 'LUNA',
        'leo': 'SOL',
        'virgo': 'MERCURIO',
        'libra': 'VENUS',
        'escorpio': 'MARTE',
        'ofiuco': 'SATURNO',
        'sagitario': 'JÚPITER',
        'capricornio': 'SOL',
        'acuario': 'LUNA',
        'piscis': 'JÚPITER'
    };
    
    return regentes[signo] || '';
}

// Función para marcar qué periodos están activos
function marcarPeriodosActivos(periodos, fechaTransito) {
    console.log("Marcando periodos activos para fecha:", fechaTransito);
    
    // Recorrer todos los periodos
    for (const periodo of periodos) {
        try {
            // Convertir fechas a objetos Date
            const fechaInicio = convertirFechaRobusta(periodo.fechaInicio);
            const fechaFin = convertirFechaRobusta(periodo.fechaFin);
            
            // Verificar si este periodo está activo
            periodo.activo = fechaTransito >= fechaInicio && fechaTransito <= fechaFin;
            
            console.log(`Periodo ${periodo.signo}: ${periodo.fechaInicio} - ${periodo.fechaFin}, Activo: ${periodo.activo}`);
            
            // Si tiene subperiodos, marcarlos también
            if (periodo.subperiodos && periodo.subperiodos.length > 0) {
                marcarPeriodosActivos(periodo.subperiodos, fechaTransito);
            }
        } catch (e) {
            console.error("Error al procesar periodo:", periodo, e);
        }
    }
}

// Función mejorada para convertir fechas
function convertirFechaRobusta(fechaStr) {
    try {
        // Si es una fecha ya formateada con barras (dd/mm/yyyy)
        if (typeof fechaStr === 'string' && fechaStr.includes('/')) {
            const partes = fechaStr.split('/');
            if (partes.length === 3) {
                // Formato español: dd/mm/yyyy
                return new Date(
                    parseInt(partes[2]), // año
                    parseInt(partes[1]) - 1, // mes (0-11)
                    parseInt(partes[0]) // día
                );
            }
        }
        
        // Si es una fecha ISO o un objeto Date
        return new Date(fechaStr);
    } catch (e) {
        console.error("Error al convertir fecha:", fechaStr, e);
        throw new Error(`No se pudo convertir la fecha: ${fechaStr}`);
    }
}

// Función auxiliar para calcular relevo zodiacal sin depender del backend
function calcularRelevoZodiacalManual(fechaNac, ascendente, fechaTransito) {
    // Normalizar el ascendente
    const ascNormalizado = normalizarSigno(ascendente);
    
    // Verificar fechas
    if (!fechaNac || !fechaTransito) {
        throw new Error("Fechas de nacimiento o tránsito no proporcionadas");
    }
    
    // Convertir fechas a objetos Date si son strings
    const fechaNacDate = typeof fechaNac === 'string' ? new Date(fechaNac) : fechaNac;
    const fechaTransitoDate = typeof fechaTransito === 'string' ? new Date(fechaTransito) : fechaTransito;
    
    // Configuración de signos y sus propiedades
    const SIGNOS_CONFIG = {
        'aries': {elemento: 'Fuego', regente: 'Marte', años: 5},
        'tauro': {elemento: 'Tierra', regente: 'Venus', años: 3},
        'geminis': {elemento: 'Aire', regente: 'Mercurio', años: 4},
        'cancer': {elemento: 'Agua', regente: 'Luna', años: 6},
        'leo': {elemento: 'Fuego', regente: 'Sol', años: 1},
        'virgo': {elemento: 'Tierra', regente: 'Mercurio', años: 4},
        'libra': {elemento: 'Aire', regente: 'Venus', años: 3},
        'escorpio': {elemento: 'Agua', regente: 'Marte', años: 5},
        'ofiuco': {elemento: 'Aire', regente: 'Saturno', años: 7},
        'sagitario': {elemento: 'Fuego', regente: 'Júpiter', años: 2},
        'capricornio': {elemento: 'Tierra', regente: 'Sol', años: 1},
        'acuario': {elemento: 'Aire', regente: 'Luna', años: 6},
        'piscis': {elemento: 'Agua', regente: 'Júpiter', años: 2}
    };
    
    // Secuencia de signos
    const SECUENCIA_SIGNOS = [
        'aries', 'tauro', 'geminis', 'cancer', 'leo', 'virgo', 'libra', 
        'escorpio', 'ofiuco', 'sagitario', 'capricornio', 'acuario', 'piscis'
    ];
    
    // Generar secuencia desde el ascendente
    const secuencia = generarSecuenciaDesdeAscendente(ascNormalizado, SECUENCIA_SIGNOS);
    
    // Constantes para duración de periodos
    const DURACION_AÑO = 364; // días
    
    // Calcular edad actual de la persona
    const edadActual = calcularEdad(fechaNacDate, fechaTransitoDate);
    console.log("Edad actual:", edadActual);
    
    // Calcular periodos
    const periodos = [];
    let periodoActivoEncontrado = false;
    let diaActual = 0;
    let edadInicial = 0;
    
    // Para cada signo en la secuencia, evaluar si el periodo actual está activo
    for (let i = 0; i < secuencia.length; i++) {
        const signo = secuencia[i];
        const config = SIGNOS_CONFIG[signo];
        
        if (!config) {
            console.error(`Configuración no encontrada para el signo: ${signo}`);
            continue;
        }
        
        const añosPeriodo = config.años;
        const diasPeriodo = añosPeriodo * DURACION_AÑO;
        
        // Fecha inicio y fin del periodo
        const fechaInicio = new Date(fechaNacDate.getTime() + diaActual * 24 * 60 * 60 * 1000);
        const fechaFin = new Date(fechaInicio.getTime() + diasPeriodo * 24 * 60 * 60 * 1000);
        
        // Verificar si el periodo está activo en la fecha de tránsito
        const periodoActivo = fechaTransitoDate >= fechaInicio && fechaTransitoDate <= fechaFin;
        
        if (periodoActivo) {
            periodoActivoEncontrado = true;
        }
        
        // Este periodo está activo
        const periodo = {
            signo: signo,
            nivel: 1,
            fechaInicio: formatearFecha(fechaInicio),
            fechaFin: formatearFecha(fechaFin),
            edad: edadInicial,
            regente: config.regente,
            elemento: config.elemento,
            activo: periodoActivo,
            subperiodos: []
        };
        
        // Calcular subperiodos solo para el periodo activo o el primer periodo
        if (periodoActivo || (!periodoActivoEncontrado && i === 0)) {
            // Calcular subperiodos (nivel 2) - usar misma lógica pero con meses
            const subperiodos = calcularSubperiodos(
                signo, 
                fechaNacDate, 
                fechaInicio, 
                fechaFin,
                fechaTransitoDate,
                secuencia,
                SIGNOS_CONFIG,
                2,
                edadInicial
            );
            
            periodo.subperiodos = subperiodos;
        }
        
        periodos.push(periodo);
        
        // Si ya encontramos el periodo activo y hemos calculado más de 2 periodos, salir
        if (periodoActivoEncontrado && periodos.length > 2) {
            break;
        }
        
        // Actualizar contadores para el siguiente periodo
        diaActual += diasPeriodo;
        edadInicial += añosPeriodo;
    }
    
    return periodos;
}

// Función para calcular subperíodos de manera recursiva
function calcularSubperiodos(fechaNac, secuencia, indiceInicial, fechaInicioPeriodo, duracionPeriodo, posicionEnPeriodo, nivel, planetasPadre, fechaTransito) {
    // Variables para el cálculo de subperíodos
    const subperiodos = [];
    let diaActual = 0;
    
    // Determinar la unidad de tiempo según el nivel
    let unidadTiempo = 'AÑO';
    if (nivel === 2) unidadTiempo = 'MES';
    else if (nivel === 3) unidadTiempo = 'SEMANA';
    else if (nivel === 4) unidadTiempo = 'DIA';
    
    // Convertir planetasPadre a array si no lo es
    if (!Array.isArray(planetasPadre)) {
        planetasPadre = [planetasPadre];
    }
    
    // Factor de conversión según el nivel
    const factorConversion = DURACIONES[unidadTiempo];
    
    // Buscar el subperíodo activo
    while (diaActual < duracionPeriodo) {
        for (let i = 0; i < secuencia.length && diaActual < duracionPeriodo; i++) {
            const signo = secuencia[(indiceInicial + i) % secuencia.length];
            const duracionSubperiodo = DURACION_POR_NIVEL[signo] * factorConversion;
            
            // Calcular cuántos días reales corresponden a este subperíodo
            const diasRestantes = duracionPeriodo - diaActual;
            const diasReales = Math.min(duracionSubperiodo, diasRestantes);
            
            // Fecha de inicio y fin del subperíodo
            const fechaInicioSub = new Date(fechaInicioPeriodo.getTime() + diaActual * 24 * 60 * 60 * 1000);
            const fechaFinSub = new Date(fechaInicioSub.getTime() + diasReales * 24 * 60 * 60 * 1000);
            
            // Determinar si este subperíodo está activo
            const esActivo = (
                fechaTransito >= fechaInicioSub && 
                fechaTransito < fechaFinSub
            );
            
            // Obtener planeta regente de este signo
            const planetaActual = getRegenteSigno(signo);
            
            // Verificar si el planeta coincide con algún planeta superior
            const coincidePlaneta = planetasPadre.includes(planetaActual);
            
            // Crear objeto para este subperíodo
            const subperiodoObj = {
                signo: signo,
                nivel: nivel,
                fechaInicio: fechaInicioSub.toLocaleDateString('es-ES'),
                fechaFin: fechaFinSub.toLocaleDateString('es-ES'),
                edad: calcularEdad(fechaNac, fechaInicioSub),
                elemento: getElementoSigno(signo),
                regente: planetaActual,
                activo: esActivo,
                coincidePlaneta: coincidePlaneta,
                subperiodos: []
            };
            
            // Si es activo o es el primero y estamos en nivel 2, calcular subperíodos recursivamente
            if (esActivo && nivel < 4) {
                const nuevaPosicion = posicionEnPeriodo - diaActual;
                const nuevosPlanetas = [...planetasPadre, planetaActual];
                
                subperiodoObj.subperiodos = calcularSubperiodos(
                    fechaNac,
                    secuencia,
                    (indiceInicial + i) % secuencia.length,
                    fechaInicioSub,
                    diasReales,
                    nuevaPosicion,
                    nivel + 1,
                    nuevosPlanetas,
                    fechaTransito
                );
            }
            
            // Añadir a la lista de subperíodos
            subperiodos.push(subperiodoObj);
            
            // Avanzar los días actuales
            diaActual += diasReales;
            
            // Si ya encontramos el período activo y hemos pasado de él, podemos salir
            if (esActivo && diaActual > posicionEnPeriodo) break;
        }
    }
    
    return subperiodos;
}

// Función para generar secuencia desde el ascendente
function generarSecuenciaDesdeAscendente(ascendente, secuencia) {
    const ascNormalizado = normalizarSigno(ascendente);
    const index = secuencia.indexOf(ascNormalizado);
    
    if (index === -1) {
        console.error(`Ascendente ${ascendente} (normalizado: ${ascNormalizado}) no encontrado en secuencia`);
        return secuencia; // Devolver secuencia original si no se encuentra
    }
    
    // Rotar la secuencia desde el ascendente
    return [...secuencia.slice(index), ...secuencia.slice(0, index)];
}

// Función auxiliar para normalizar el nombre del signo
function normalizarSigno(signo) {
    // Normalizar nombre del signo
    signo = signo.toLowerCase();
    
    const normalizacion = {
        'aries': 'aries',
        'tauro': 'tauro',
        'taurus': 'tauro',
        'gemini': 'geminis',
        'geminis': 'geminis',
        'géminis': 'geminis',
        'cancer': 'cancer',
        'cáncer': 'cancer',
        'leo': 'leo',
        'virgo': 'virgo',
        'libra': 'libra',
        'scorpio': 'escorpio',
        'escorpio': 'escorpio',
        'ophiuchus': 'ofiuco',
        'ofiuco': 'ofiuco',
        'sagittarius': 'sagitario',
        'sagitario': 'sagitario',
        'capricorn': 'capricornio',
        'capricornio': 'capricornio',
        'aquarius': 'acuario',
        'acuario': 'acuario',
        'pisces': 'piscis',
        'piscis': 'piscis'
    };
    
    return normalizacion[signo] || 'aries';
}

// Función para calcular edad
function calcularEdad(fechaNac, fechaActual) {
    let edad = fechaActual.getFullYear() - fechaNac.getFullYear();
    const m = fechaActual.getMonth() - fechaNac.getMonth();
    
    if (m < 0 || (m === 0 && fechaActual.getDate() < fechaNac.getDate())) {
        edad--;
    }
    
    return edad;
}

// Función para calcular edad con precisión
function calcularEdadExacta(fechaNac, fechaActual) {
    // Años completos
    let años = calcularEdad(fechaNac, fechaActual);
    
    // Días desde último cumpleaños
    const ultimoCumpleaños = new Date(fechaActual.getFullYear(), fechaNac.getMonth(), fechaNac.getDate());
    if (ultimoCumpleaños > fechaActual) {
        ultimoCumpleaños.setFullYear(ultimoCumpleaños.getFullYear() - 1);
    }
    
    const milisPorDia = 24 * 60 * 60 * 1000;
    const diasDesdeUltimoCumpleaños = Math.floor((fechaActual - ultimoCumpleaños) / milisPorDia);
    
    // Expresar como edad decimal (por ejemplo, 25.7 años)
    return años + (diasDesdeUltimoCumpleaños / 365).toFixed(1) * 1;
}

// Función para formatear fecha
function formatearFecha(fecha) {
    return fecha.toLocaleDateString('es-ES', {
        day: '2-digit',
        month: '2-digit',
        year: 'numeric'
    });
}

// Versión mejorada de la función calcularRelevoZodiacal
function calcularRelevoZodiacal(birthDate, ascendente, transitDate) {
    // Convertir fechas a objetos Date
    const fechaNac = new Date(birthDate);
    const fechaTransito = new Date(transitDate);
    
    // Calcular la diferencia en años entre nacimiento y tránsito
    const edadActualAprox = Math.floor((fechaTransito - fechaNac) / (365.25 * 24 * 60 * 60 * 1000));
    
    console.log("Edad aproximada en fecha de tránsito:", edadActualAprox, "años");
    
    // Generar secuencia de signos a partir del ascendente
    const secuencia = generarSecuencia(ascendente);
    console.log("Secuencia de signos generada:", secuencia);
    
    // Periodos activos para la fecha de tránsito
    const periodosActivos = [];
    
    // Calcular el número total de días desde el nacimiento hasta la fecha de tránsito
    const diasTotales = Math.floor((fechaTransito - fechaNac) / (24 * 60 * 60 * 1000));
    
    // Calcular años completos para cada signo del zodíaco y acumular días
    let diaActual = 0;
    let añoActual = 0;
    let periodoActualEncontrado = false;
    
    // Ajustar para considerar múltiples ciclos de la secuencia si es necesario
    // Una persona de 84 años habrá pasado por la secuencia completa varias veces
    const ciclosCompletos = Math.floor(edadActualAprox / 14); // Hay 13 signos en total
    
    // Calcular días acumulados en ciclos completos
    if (ciclosCompletos > 0) {
        let diasEnCicloCompleto = 0;
        for (const signo of secuencia) {
            diasEnCicloCompleto += DURACION_POR_NIVEL[signo] * DURACIONES.AÑO;
        }
        diaActual = ciclosCompletos * diasEnCicloCompleto;
        añoActual = ciclosCompletos * 14; // Aproximación de años
    }
    
    // Continuar desde el punto calculado
    while (diaActual < diasTotales && !periodoActualEncontrado) {
        for (let i = 0; i < secuencia.length; i++) {
            const signo = secuencia[i];
            
            if (!DURACION_POR_NIVEL[signo]) {
                console.warn(`Signo "${signo}" no encontrado en DURACION_POR_NIVEL, saltando...`);
                continue;
            }
            
            const anios = DURACION_POR_NIVEL[signo];
            const diasEnPeriodo = anios * DURACIONES.AÑO;
            
            // Calcular fecha de inicio y fin del periodo
            const fechaInicio = new Date(fechaNac);
            fechaInicio.setDate(fechaInicio.getDate() + diaActual);
            
            const fechaFin = new Date(fechaInicio);
            fechaFin.setDate(fechaInicio.getDate() + diasEnPeriodo);
            
            // Comprobar si la fecha de tránsito está dentro de este periodo
            if (fechaTransito >= fechaInicio && fechaTransito <= fechaFin) {
                console.log("Encontrado periodo activo: " + signo);
                console.log("  Edad: " + calcularEdad(fechaNac, fechaInicio));
                
                // Crear objeto de periodo principal
                const periodo = {
                    signo: signo,
                    nivel: 1,
                    fechaInicio: fechaInicio.toLocaleDateString('es-ES'),
                    fechaFin: fechaFin.toLocaleDateString('es-ES'),
                    edad: añoActual + i,
                    elemento: elementosSignos[signo] || 'Neutral',
                    regente: regentesSignos[signo] || 'Desconocido',
                    activo: true,
                    subperiodos: []
                };
                
                // Calcular subperiodos con precisión mejorada
                // Usar un subconjunto de días específico para este periodo
                const diasInicioPeriodo = diaActual;
                const duracionPeriodo = diasEnPeriodo;
                
                // Subperiodos (meses - nivel 2)
                const subSecuencia = generarSecuencia(signo);
                let diaSubperiodo = 0;
                
                while (diaSubperiodo < duracionPeriodo) {
                    for (let j = 0; j < subSecuencia.length && diaSubperiodo < duracionPeriodo; j++) {
                        const subSigno = subSecuencia[j];
                        
                        if (!DURACION_POR_NIVEL[subSigno]) continue;
                        
                        const meses = DURACION_POR_NIVEL[subSigno];
                        const diasEnSubperiodo = meses * DURACIONES.MES;
                        
                        // Asegurar que no exceda la duración del periodo principal
                        const diasRealesSubperiodo = Math.min(diasEnSubperiodo, duracionPeriodo - diaSubperiodo);
                        
                        if (diasRealesSubperiodo <= 0) break;
                        
                        // Calcular fecha de inicio y fin del subperiodo
                        const fechaInicioSub = new Date(fechaNac);
                        fechaInicioSub.setDate(fechaInicioSub.getDate() + diasInicioPeriodo + diaSubperiodo);
                        
                        const fechaFinSub = new Date(fechaInicioSub);
                        fechaFinSub.setDate(fechaInicioSub.getDate() + diasRealesSubperiodo);
                        
                        // Comprobar si la fecha de tránsito está dentro de este subperiodo
                        let subperiodoActivo = false;
                        if (fechaTransito >= fechaInicioSub && fechaTransito <= fechaFinSub) {
                            console.log("  Encontrado subperiodo activo: " + subSigno);
                            subperiodoActivo = true;
                        }
                        
                        // Crear objeto subperiodo
                        const subperiodo = {
                            signo: subSigno,
                            nivel: 2,
                            fechaInicio: fechaInicioSub.toLocaleDateString('es-ES'),
                            fechaFin: fechaFinSub.toLocaleDateString('es-ES'),
                            edad: periodo.edad,
                            elemento: elementosSignos[subSigno] || 'Neutral',
                            regente: regentesSignos[subSigno] || 'Desconocido',
                            activo: subperiodoActivo,
                            subperiodos: []
                        };
                        
                        // Solo calcular sub-subperiodos para el subperiodo activo
                        if (subperiodoActivo) {
                            // Sub-subperiodos (semanas - nivel 3)
                            const subSubSecuencia = generarSecuencia(subSigno);
                            let diaSubSubperiodo = 0;
                            
                            while (diaSubSubperiodo < diasRealesSubperiodo) {
                                for (let k = 0; k < subSubSecuencia.length && diaSubSubperiodo < diasRealesSubperiodo; k++) {
                                    const subSubSigno = subSubSecuencia[k];
                                    
                                    if (!DURACION_POR_NIVEL[subSubSigno]) continue;
                                    
                                    const semanas = DURACION_POR_NIVEL[subSubSigno];
                                    const diasEnSubSubperiodo = semanas * DURACIONES.SEMANA;
                                    
                                    // Asegurar que no exceda la duración del subperiodo
                                    const diasRealesSubSubperiodo = Math.min(diasEnSubSubperiodo, diasRealesSubperiodo - diaSubSubperiodo);
                                    
                                    if (diasRealesSubSubperiodo <= 0) break;
                                    
                                    // Calcular fecha de inicio y fin del sub-subperiodo
                                    const fechaInicioSubSub = new Date(fechaNac);
                                    fechaInicioSubSub.setDate(fechaInicioSubSub.getDate() + diasInicioPeriodo + diaSubperiodo + diaSubSubperiodo);
                                    
                                    const fechaFinSubSub = new Date(fechaInicioSubSub);
                                    fechaFinSubSub.setDate(fechaInicioSubSub.getDate() + diasRealesSubSubperiodo);
                                    
                                    // Comprobar si la fecha de tránsito está dentro de este sub-subperiodo
                                    let subSubperiodoActivo = false;
                                    if (fechaTransito >= fechaInicioSubSub && fechaTransito <= fechaFinSubSub) {
                                        console.log("    Encontrado sub-subperiodo activo: " + subSubSigno);
                                        subSubperiodoActivo = true;
                                    }
                                    
                                    // Crear objeto sub-subperiodo
                                    const subSubperiodo = {
                                        signo: subSubSigno,
                                        nivel: 3,
                                        fechaInicio: fechaInicioSubSub.toLocaleDateString('es-ES'),
                                        fechaFin: fechaFinSubSub.toLocaleDateString('es-ES'),
                                        edad: periodo.edad,
                                        elemento: elementosSignos[subSubSigno] || 'Neutral',
                                        regente: regentesSignos[subSubSigno] || 'Desconocido',
                                        activo: subSubperiodoActivo,
                                        subperiodos: []
                                    };
                                    
                                    // Solo calcular nivel 4 (días) para el sub-subperiodo activo
                                    if (subSubperiodoActivo) {
                                        // Días (nivel 4)
                                        const subSubSubSecuencia = generarSecuencia(subSubSigno);
                                        let diaSubSubSubperiodo = 0;
                                        
                                        while (diaSubSubSubperiodo < diasRealesSubSubperiodo) {
                                            for (let l = 0; l < subSubSubSecuencia.length && diaSubSubSubperiodo < diasRealesSubSubperiodo; l++) {
                                                const subSubSubSigno = subSubSubSecuencia[l];
                                                
                                                if (!DURACION_POR_NIVEL[subSubSubSigno]) continue;
                                                
                                                const dias = DURACION_POR_NIVEL[subSubSubSigno];
                                                const diasEnSubSubSubperiodo = dias * DURACIONES.DIA;
                                                
                                                // Asegurar que no exceda la duración del sub-subperiodo
                                                const diasRealesSubSubSubperiodo = Math.min(diasEnSubSubSubperiodo, diasRealesSubSubperiodo - diaSubSubSubperiodo);
                                                
                                                if (diasRealesSubSubSubperiodo <= 0) break;
                                                
                                                // Calcular fecha de inicio y fin del sub-sub-subperiodo
                                                const fechaInicioSubSubSub = new Date(fechaNac);
                                                fechaInicioSubSubSub.setDate(fechaInicioSubSubSub.getDate() + diasInicioPeriodo + diaSubperiodo + diaSubSubperiodo + diaSubSubSubperiodo);
                                                
                                                const fechaFinSubSubSub = new Date(fechaInicioSubSubSub);
                                                fechaFinSubSubSub.setDate(fechaInicioSubSubSub.getDate() + diasRealesSubSubSubperiodo);
                                                
                                                // Comprobar si la fecha de tránsito está dentro de este día específico
                                                let diaActivo = false;
                                                if (fechaTransito >= fechaInicioSubSubSub && fechaTransito <= fechaFinSubSubSub) {
                                                    console.log("      Encontrado día activo: " + subSubSubSigno);
                                                    diaActivo = true;
                                                }
                                                
                                                // Crear objeto de nivel 4 para el día activo
                                                if (diaActivo) {
                                                    const subSubSubperiodo = {
                                                        signo: subSubSubSigno,
                                                        nivel: 4,
                                                        fechaInicio: fechaInicioSubSubSub.toLocaleDateString('es-ES'),
                                                        fechaFin: fechaFinSubSubSub.toLocaleDateString('es-ES'),
                                                        edad: periodo.edad,
                                                        elemento: elementosSignos[subSubSubSigno] || 'Neutral',
                                                        regente: regentesSignos[subSubSubSigno] || 'Desconocido',
                                                        activo: true
                                                    };
                                                    
                                                    // Añadir solo el día activo
                                                    subSubperiodo.subperiodos.push(subSubSubperiodo);
                                                }
                                                
                                                diaSubSubSubperiodo += diasRealesSubSubSubperiodo;
                                            }
                                        }
                                    }
                                    
                                    // Añadir solo el sub-subperiodo activo
                                    if (subSubperiodoActivo) {
                                        subperiodo.subperiodos.push(subSubperiodo);
                                    }
                                    
                                    diaSubSubperiodo += diasRealesSubSubperiodo;
                                }
                            }
                        }
                        
                        // Añadir solo el subperiodo activo
                        if (subperiodoActivo) {
                            periodo.subperiodos.push(subperiodo);
                        }
                        
                        diaSubperiodo += diasRealesSubperiodo;
                    }
                }
                
                periodosActivos.push(periodo);
                periodoActualEncontrado = true;
                break; // Salir del bucle, ya encontramos el periodo activo
            }
            
            // Avanzar al siguiente periodo principal
            diaActual += diasEnPeriodo;
            if (diaActual >= diasTotales) {
                break;
            }
        }
        
        // Si ya completamos una secuencia completa y no encontramos el periodo,
        // podemos estar en un ciclo posterior. Incrementamos el contador de años
        // para llevar un seguimiento aproximado.
        añoActual += secuencia.length;
    }
    
    console.log("Relevo zodiacal completado");
    
    return periodosActivos;
}

// Función para calcular la edad en una fecha específica
function calcularEdad(fechaNac, fechaActual) {
    let edad = fechaActual.getFullYear() - fechaNac.getFullYear();
    const m = fechaActual.getMonth() - fechaNac.getMonth();
    
    if (m < 0 || (m === 0 && fechaActual.getDate() < fechaNac.getDate())) {
        edad--;
    }
    
    return edad;
}

const handleCalculate = () => {
    if (!selectedCity || !date || !time) {
        setError("Debes ingresar ciudad, fecha y hora.");
        return;
    }

    const apiUrl = `https://carta-astral.onrender.com/calculate`;

    fetch(apiUrl, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({
            city: selectedCity,
            date: date,
            time: time,
            includeStars: true  // Añadir esta línea para incluir estrellas
        })
    })
    .then(response => response.json())
    .then(data => {
        if (data.error) throw new Error(data.error);

        setPlanets(data.positions || []);
        setAspects(data.aspects || []);
        setDignityTable(data.dignity_table || null);
        setBirthType(data.houses_analysis?.birth_type || null);
        setTriplicityTable(data.houses_analysis?.houses || null);
        setInterpretations(data.interpretations || {
            planets_in_signs: [],
            planets_in_houses: [],
            aspects: [],
            house_rulers: []
        });

        document.getElementById("location").innerHTML = `<b>Ciudad:</b> ${selectedCity}`;
        document.getElementById("timezone").innerHTML = `<b>Huso horario:</b> ${data.timezone?.name || 'N/A'} (${data.timezone?.abbreviation_DST || 'N/A'})`;
        document.getElementById("coordinates").innerHTML = `<b>Coordenadas:</b> Lat ${data.coordinates?.latitude || 'N/A'}, Lon ${data.coordinates?.longitude || 'N/A'}`;

        // Aquí es donde debes añadir el procesamiento de estrellas
        // Procesar estrellas fijas si están incluidas en la respuesta
        if (data.stars) {
            const starData = [];
            
            // Procesar estrellas activas
            if (data.stars.active_stars) {
                data.stars.active_stars.forEach(star => {
                    // Buscar datos adicionales en nuestra constante FIXED_STARS
                    const fixedStarData = FIXED_STARS.find(s => s.name === star.name);
                    if (fixedStarData) {
                        starData.push({
                            ...fixedStarData,
                            longitude: star.longitude,
                            sign: star.sign,
                            conjunctPlanets: [{
                                name: star.planet,
                                diff: star.angle.toFixed(2)
                            }],
                            isActive: true
                        });
                    }
                });
            }
            
            setActiveStars(starData);
        }

        setError("");
    })
    .catch(err => {
        console.error('Error:', err);
        setError(`Error en la consulta: ${err.message}`);
    });
};

// En lugar de crear un componente React separado, vamos a crear una función
// que genere el HTML para la sección de estrellas fijas
function renderFixedStarsSection(stars, selectedPlanet, handleStarClick) {
    if (!stars || stars.length === 0) {
        return '';
    }
    
    // Filtrar estrellas relevantes si hay un planeta seleccionado
    const relevantStars = selectedPlanet 
        ? stars.filter(star => star.conjunctPlanets && star.conjunctPlanets.some(p => p.name === selectedPlanet))
        : stars;
        
    if (relevantStars.length === 0) {
        return `
            <div class="fixed-stars-container">
                <h3>Estrellas Fijas ${selectedPlanet ? `en conjunción con ${selectedPlanet}` : ''}</h3>
                <p>No hay estrellas fijas relevantes ${selectedPlanet ? `para ${selectedPlanet}` : 'activas'}.</p>
            </div>
        `;
    }
    
    // Construir HTML para cada estrella
    const starsHtml = relevantStars.map((star, index) => `
        <div 
            class="star-item ${star.selected ? 'selected' : ''}"
            onclick="handleStarClick('${star.name}')"
        >
            <div class="star-header">
                <span class="star-symbol">★</span> 
                <strong>${star.name}</strong> - ${star.sign} (${star.longitude.toFixed(2)}°)
            </div>
            
            <div class="star-details">
                <div>
                    <strong>Conjunción con:</strong> ${
                        star.conjunctPlanets && star.conjunctPlanets.map(p => 
                            `${p.name} (${p.diff}°)`
                        ).join(', ')
                    }
                </div>
                <div><strong>Efecto:</strong> ${star.effect}</div>
                <div><strong>Enlace:</strong> <a href="${star.filePath}" class="star-link" target="_blank" onclick="event.stopPropagation();">${star.name}</a></div>
            </div>
        </div>
    `).join('');
    
    return `
        <div class="fixed-stars-container">
            <h3>Estrellas Fijas ${selectedPlanet ? `en conjunción con ${selectedPlanet}` : ''}</h3>
            <div class="stars-list">
                ${starsHtml}
            </div>
        </div>
    `;
}
        // Funciones globales para acceso desde HTML
        window.toggleYearGroup = toggleYearGroup;
        window.showTransitForDate = showTransitForDate;
        window.seleccionarPuntoReferencia = seleccionarPuntoReferencia;
        window.calcularYMostrarRelevoZodiacal = calcularYMostrarRelevoZodiacal;

<!-- 5. Agregar event listener para el toggle del zodiaco sideral -->
// Inicialización
function init() {
    console.log("Inicializando aplicación...");
    
    // Establecer fecha y hora actuales
    const now = new Date();
    dateInput.value = now.toISOString().split('T')[0];
    timeInput.value = now.toTimeString().slice(0, 5);
    
    transitDateInput.value = now.toISOString().split('T')[0];
    transitTimeInput.value = now.toTimeString().slice(0, 5);
    
    // Establecer ciudad predeterminada
    cityInput.value = "Bilbao, España";
    transitCityInput.value = "Bilbao, España";
    
    // Event listeners para búsqueda de ciudades
    cityInput.addEventListener('input', debounce(function() {
        handleCitySearch(cityInput.value, false);
    }, 300));
    
    transitCityInput.addEventListener('input', debounce(function() {
        handleCitySearch(transitCityInput.value, true);
    }, 300));
    
    // Event listeners para toggles y botones
    showTransitsToggle.addEventListener('change', toggleTransits);
    calculateBtn.addEventListener('click', calculateChart);
    
    // Event listeners para filtros de predicciones
    yearFilterSelect.addEventListener('change', renderPredictions);
    tipoPrediccionSelect.addEventListener('change', renderPredictions);
    
    // Event listener para toggle de zodiaco sideral
    const siderealZodiacToggle = document.getElementById('useSiderealZodiac');
    if (siderealZodiacToggle) {
        siderealZodiacToggle.addEventListener('change', function() {
            // Si ya tenemos una carta calculada, volver a calcularla
            if (natalPlanets.length > 0) {
                console.log("Recalculando carta con nuevo sistema zodiacal: " + (this.checked ? "Sideral" : "Tropical"));
                calculateChart();
            }
        });
    }
           
    // Configurar inicialmente los controles de tránsitos
    toggleTransits();
    
    // Ocultar loading
    loadingIndicator.style.display = 'none';
    
    console.log("Aplicación inicializada correctamente");
}

// Inicializar la aplicación cuando el DOM esté listo
document.addEventListener('DOMContentLoaded', init);
        init();
    });

    </script>
</body>
</html>
renderChart    